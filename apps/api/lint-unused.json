[{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\assign_super_admin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\debug_prisma_client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\fix_booking_status.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\list_slugs_json.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\seed_blogs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\seed_featured_trips.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\seed_test_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\seed_trips.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\prisma\\seed_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\assignSuperAdmin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\checkPermissions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\check_admin_bookings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\check_booking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\check_trip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\cleanup_keep_superadmins.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\cleanup_test_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\cloud_migrate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\convert-requires.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\create_content_manager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\ensure_admin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\fix-catch-identifier.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\fix-empty-blocks.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\get_metrics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\grant_metrics_permission.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\lifecycle_test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\phase3_2_test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\populate_guide_trips.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\seed_admin_booking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\seed_reviews.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\setup_admin_trip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_admin_calls.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_admin_calls_for.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_admin_fetch.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_admin_list_bookings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_booking_capacity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_booking_permissions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_booking_transitions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[111,114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[111,114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[119,122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[119,122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[497,500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[497,500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[872,875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[872,875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[890,893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[890,893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[999,1002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[999,1002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1016,1019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1016,1019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1156,1159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1156,1159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1174,1177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1174,1177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1273,1276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1273,1276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1291,1294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1291,1294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { assertBookingTransition } from \"../src/domain/booking/bookingTransitions\";\r\n\r\nfunction expectEqual(a: any, b: any, msg?: string) {\r\n  if (a !== b) {\r\n    console.error(`FAIL: ${msg || \"\"} — expected ${b}, got ${a}`);\r\n    process.exitCode = 1;\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nfunction expectThrows(fn: () => void, msg?: string) {\r\n  try {\r\n    fn();\r\n    console.error(`FAIL: ${msg || \"\"} — expected throw but did not`);\r\n    process.exitCode = 1;\r\n    process.exit(1);\r\n  } catch (err: any) {\r\n    if (!err || !err.message || !err.message.startsWith(\"INVALID_BOOKING_TRANSITION\")) {\r\n      console.error(`FAIL: ${msg || \"\"} — unexpected error: ${err}`);\r\n      process.exitCode = 1;\r\n      process.exit(1);\r\n    }\r\n  }\r\n}\r\n\r\nconsole.log(\"Testing booking transition validator...\");\r\n\r\n// Valid transitions\r\nexpectEqual(\r\n  assertBookingTransition(\"REQUESTED\" as any, \"approve\" as any),\r\n  \"CONFIRMED\",\r\n  \"REQUESTED -> approve\",\r\n);\r\nexpectEqual(\r\n  assertBookingTransition(\"REQUESTED\" as any, \"reject\" as any),\r\n  \"REJECTED\",\r\n  \"REQUESTED -> reject\",\r\n);\r\n\r\n// Invalid transitions\r\nexpectThrows(\r\n  () => assertBookingTransition(\"CONFIRMED\" as any, \"approve\" as any),\r\n  \"CONFIRMED -> approve\",\r\n);\r\nexpectThrows(\r\n  () => assertBookingTransition(\"REJECTED\" as any, \"approve\" as any),\r\n  \"REJECTED -> approve\",\r\n);\r\n\r\nconsole.log(\"All booking transition tests passed\");\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_bookings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_create_intent_env.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_image_processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_join_trip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_prod_guard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_trips.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_webhook_e2e.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1748,1751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1748,1751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1872,1875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1872,1875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1932,1935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1932,1935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2036,2039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2036,2039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import \"dotenv/config\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport crypto from \"crypto\";\r\n\r\n(async function main() {\r\n  process.env.RAZORPAY_WEBHOOK_SECRET = \"testsecret\";\r\n  const prisma = new PrismaClient();\r\n  try {\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email: `test.pay+${Date.now()}@local.test`,\r\n        password: \"x\",\r\n        name: \"Test Pay\",\r\n      },\r\n    });\r\n    const trip = await prisma.trip.create({\r\n      data: {\r\n        title: \"T\",\r\n        slug: `t-${Date.now()}`,\r\n        description: \"d\",\r\n        itinerary: [],\r\n        durationDays: 1,\r\n        difficulty: \"easy\",\r\n        location: \"here\",\r\n        price: 1000,\r\n        status: \"PUBLISHED\",\r\n        createdById: user.id,\r\n      },\r\n    });\r\n    const booking = await prisma.booking.create({\r\n      data: { userId: user.id, tripId: trip.id, status: \"CONFIRMED\" },\r\n    });\r\n    const orderId = `order_test_${Date.now()}`;\r\n    const payment = await prisma.payment.create({\r\n      data: {\r\n        bookingId: booking.id,\r\n        provider: \"razorpay\",\r\n        providerOrderId: orderId,\r\n        amount: trip.price,\r\n        status: \"CREATED\",\r\n      },\r\n    });\r\n\r\n    console.log(\"Created:\", { bookingId: booking.id, paymentId: payment.id });\r\n\r\n    const razorpayPaymentId = `pay_test_${Date.now()}`;\r\n    const payload = JSON.stringify({\r\n      event: \"payment.captured\",\r\n      payload: {\r\n        payment: { entity: { id: razorpayPaymentId, order_id: orderId } },\r\n      },\r\n    });\r\n    const sig = crypto\r\n      .createHmac(\"sha256\", process.env.RAZORPAY_WEBHOOK_SECRET!)\r\n      .update(payload)\r\n      .digest(\"hex\");\r\n\r\n    const mod = await import(\"../src/controllers/razorpayWebhook.controller\");\r\n    const req: any = {\r\n      headers: { \"x-razorpay-signature\": sig },\r\n      body: Buffer.from(payload, \"utf8\"),\r\n    };\r\n    const res: any = {\r\n      status: (s: number) => ({\r\n        json: (o: any) => {\r\n          console.log(\"RESPONSE\", s, o);\r\n        },\r\n      }),\r\n    };\r\n\r\n    await (mod as any).razorpayWebhookHandler(req, res);\r\n\r\n    const afterPayment = await prisma.payment.findUnique({\r\n      where: { id: payment.id },\r\n    });\r\n    const afterBooking = await prisma.booking.findUnique({\r\n      where: { id: booking.id },\r\n    });\r\n\r\n    console.log(\"After:\", { payment: afterPayment, booking: afterBooking });\r\n  } catch (err) {\r\n    console.error(\"ERR\", err);\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_webhook_http.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_webhook_http.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\test_webhook_replay.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1474,1477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1474,1477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1598,1601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1598,1601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1658,1661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1658,1661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1928,1931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1928,1931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import \"dotenv/config\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport crypto from \"crypto\";\r\n\r\n(async function main() {\r\n  process.env.RAZORPAY_WEBHOOK_SECRET = process.env.RAZORPAY_WEBHOOK_SECRET || \"testsecret\";\r\n  const prisma = new PrismaClient();\r\n  try {\r\n    // Find an existing payment that is already CAPTURED (so replay makes sense)\r\n    const payment = await prisma.payment.findFirst({\r\n      where: { status: \"CAPTURED\", provider: \"razorpay\" },\r\n      orderBy: { updatedAt: \"desc\" },\r\n    });\r\n\r\n    if (!payment) {\r\n      console.error(\"No captured razorpay payment found to replay. Run test_webhook_e2e.ts first.\");\r\n      process.exit(2);\r\n    }\r\n\r\n    const booking = await prisma.booking.findUnique({\r\n      where: { id: payment.bookingId },\r\n    });\r\n\r\n    console.log(\"Replaying webhook for:\", {\r\n      paymentId: payment.id,\r\n      providerOrderId: payment.providerOrderId,\r\n      providerPaymentId: payment.providerPaymentId,\r\n    });\r\n\r\n    const payload = JSON.stringify({\r\n      event: \"payment.captured\",\r\n      payload: {\r\n        payment: {\r\n          entity: {\r\n            id: payment.providerPaymentId,\r\n            order_id: payment.providerOrderId,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const sig = crypto\r\n      .createHmac(\"sha256\", process.env.RAZORPAY_WEBHOOK_SECRET!)\r\n      .update(payload)\r\n      .digest(\"hex\");\r\n\r\n    const mod = await import(\"../src/controllers/razorpayWebhook.controller\");\r\n    const req: any = {\r\n      headers: { \"x-razorpay-signature\": sig },\r\n      body: Buffer.from(payload, \"utf8\"),\r\n    };\r\n    const res: any = {\r\n      status: (s: number) => ({\r\n        json: (o: any) => {\r\n          console.log(\"RESPONSE\", s, o);\r\n        },\r\n      }),\r\n    };\r\n\r\n    // Snapshot before\r\n    const beforePayment = await prisma.payment.findUnique({\r\n      where: { id: payment.id },\r\n    });\r\n    const beforeBooking = booking;\r\n\r\n    await (mod as any).razorpayWebhookHandler(req, res);\r\n\r\n    const afterPayment = await prisma.payment.findUnique({\r\n      where: { id: payment.id },\r\n    });\r\n    const afterBooking = await prisma.booking.findUnique({\r\n      where: { id: payment.bookingId },\r\n    });\r\n\r\n    console.log(\"Before:\", { payment: beforePayment, booking: beforeBooking });\r\n    console.log(\"After:\", { payment: afterPayment, booking: afterBooking });\r\n  } catch (err) {\r\n    console.error(err);\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify-audit-logs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify-guide-trips.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[548,551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[548,551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[931,934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[931,934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"async function main() {\r\n  const API_URL = \"http://localhost:3001\";\r\n\r\n  // 1. Login as Guide\r\n  console.log(\"Logging in as guide...\");\r\n  const loginRes = await fetch(`${API_URL}/auth/login`, {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify({\r\n      email: \"guide@local.test\",\r\n      password: \"password123\",\r\n    }),\r\n  });\r\n\r\n  if (!loginRes.ok) {\r\n    console.error(\"Login failed:\", await loginRes.text());\r\n    process.exit(1);\r\n  }\r\n\r\n  const { accessToken } = (await loginRes.json()) as any;\r\n  console.log(\"Login successful.\");\r\n\r\n  // 2. Fetch Guide Trips\r\n  console.log(\"Fetching guide trips...\");\r\n  const res = await fetch(`${API_URL}/users/guide/trips`, {\r\n    headers: { Authorization: `Bearer ${accessToken}` },\r\n  });\r\n\r\n  if (!res.ok) {\r\n    console.error(\"Fetch failed:\", await res.text());\r\n    process.exit(1);\r\n  }\r\n\r\n  const trips = (await res.json()) as any[];\r\n  console.log(`Found ${trips.length} assigned trips.`);\r\n\r\n  if (trips.length > 0 && trips[0].slug === \"annapurna-circuit\") {\r\n    console.log(\"SUCCESS: Retrieved correct trip assignment.\");\r\n  } else {\r\n    console.error(\"FAILURE: Unexpected trip data\", JSON.stringify(trips, null, 2));\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmain().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify-profile-update.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[530,533],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[530,533],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1270,1273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1270,1273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"async function main() {\r\n  const API_URL = \"http://localhost:3001\";\r\n\r\n  // 1. Login\r\n  console.log(\"Logging in...\");\r\n  const loginRes = await fetch(`${API_URL}/auth/login`, {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify({\r\n      email: \"admin@local.test\",\r\n      password: \"password123\",\r\n    }),\r\n  });\r\n\r\n  if (!loginRes.ok) {\r\n    console.error(\"Login failed:\", await loginRes.text());\r\n    process.exit(1);\r\n  }\r\n\r\n  const { accessToken } = (await loginRes.json()) as any;\r\n  console.log(\"Login successful, token received.\");\r\n\r\n  // 2. Update Profile with Preferences\r\n  console.log(\"Updating profile preferences...\");\r\n  const newPreferences = { theme: \"dark\", notifications: { email: true, sms: false } };\r\n\r\n  const updateRes = await fetch(`${API_URL}/users/profile`, {\r\n    method: \"PATCH\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      Authorization: `Bearer ${accessToken}`,\r\n    },\r\n    body: JSON.stringify({\r\n      preferences: newPreferences,\r\n      bio: \"Updated bio via verification script\",\r\n    }),\r\n  });\r\n\r\n  if (!updateRes.ok) {\r\n    console.error(\"Update failed:\", await updateRes.text());\r\n    process.exit(1);\r\n  }\r\n\r\n  const updateData = (await updateRes.json()) as any;\r\n\r\n  // 3. Verify Response\r\n  console.log(\"Update response preferences:\", JSON.stringify(updateData.user.preferences, null, 2));\r\n  console.log(\"Expected preferences:\", JSON.stringify(newPreferences, null, 2));\r\n\r\n  if (JSON.stringify(updateData.user.preferences) === JSON.stringify(newPreferences)) {\r\n    console.log(\"SUCCESS: Preferences updated correctly.\");\r\n  } else {\r\n    console.error(\"FAILURE: Preferences did not match expected value.\");\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmain().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify-rate-limit.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[399,402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[399,402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from \"axios\";\r\n\r\nasync function main() {\r\n  const url = \"http://localhost:3000/auth/login\";\r\n  const payload = { email: \"test@test.com\", password: \"wrong\" };\r\n\r\n  console.log(\"Testing Auth Rate Limit (Max 5)...\");\r\n\r\n  for (let i = 1; i <= 7; i++) {\r\n    try {\r\n      await axios.post(url, payload);\r\n      console.log(`Request ${i}: Success (Expected 401 or 200)`);\r\n    } catch (err: any) {\r\n      if (err.response) {\r\n        if (err.response.status === 429) {\r\n          console.log(`Request ${i}: BLOCKED (429) - SUCCESS!`);\r\n        } else {\r\n          console.log(`Request ${i}: Status ${err.response.status}`);\r\n        }\r\n      } else {\r\n        console.log(`Request ${i}: Error ${err.message}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify-reset-flow.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[219,222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[219,222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[289,292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[289,292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[320,323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[320,323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from \"../src/lib/prisma\";\r\nimport { resetPassword } from \"../src/controllers/auth.controller\";\r\nimport { Request, Response } from \"express\";\r\n\r\n// Mock Express Request/Response\r\nconst mockReq = (body: any) => ({ body }) as Request;\r\nconst mockRes = () => {\r\n  const res: any = {};\r\n  res.json = (data: any) => {\r\n    res.data = data;\r\n    return res;\r\n  };\r\n  res.status = (code: number) => {\r\n    res.statusCode = code;\r\n    return res;\r\n  };\r\n  return res as Response & { data: any; statusCode: number };\r\n};\r\n\r\nasync function main() {\r\n  console.log(\"Starting Verification: Password Reset Flow\");\r\n\r\n  // 1. Create a test user\r\n  const email = `test-reset-${Date.now()}@example.com`;\r\n  const user = await prisma.user.create({\r\n    data: {\r\n      email,\r\n      password: \"OldPassword123!\",\r\n      name: \"Reset Tester\",\r\n    },\r\n  });\r\n  console.log(`1. Created user: ${email}`);\r\n\r\n  // 2. Mock the Notification Service to capture the token\r\n  // Since we can't easily intercept the real email service in this script without mocking the import,\r\n  // we will rely on a slightly different approach: we'll generate a token ourselves just to test the RESET endpoint.\r\n  // Testing the \"Forgot\" controller fully would require mocking the `import()` in the controller which is hard in this script.\r\n\r\n  // Actually, let's just test the `resetPassword` controller logic since that's the critical security part.\r\n  // The `forgotPassword` controller is mainly about sending email, which we can visually verify if needed, but the Logic is simple.\r\n\r\n  const jwt = await import(\"../src/utils/jwt\");\r\n  const token = jwt.signResetToken(user.id);\r\n  console.log(`2. Generated valid reset token: ${token.substring(0, 20)}...`);\r\n\r\n  // 3. Test Reset Password\r\n  const newPassword = \"NewPassword456!\";\r\n  const req = mockReq({ token, password: newPassword });\r\n  const res = mockRes();\r\n\r\n  await resetPassword(req, res);\r\n\r\n  if (res.data?.message === \"Password updated successfully\") {\r\n    console.log(\"3. Reset Password Controller: SUCCESS\");\r\n  } else {\r\n    console.error(\"3. Reset Password Controller: FAILED\", res.data);\r\n    process.exit(1);\r\n  }\r\n\r\n  // 4. Verify in DB\r\n  const updatedUser = await prisma.user.findUnique({ where: { id: user.id } });\r\n  // In a real test we'd import verifyPassword but we know it's hashed.\r\n  // We'll just assume success if the controller said so and the hash changed.\r\n  if (updatedUser?.password !== user.password) {\r\n    console.log(\"4. DB Verification: Password hash changed. SUCCESS\");\r\n  } else {\r\n    console.error(\"4. DB Verification: Password hash did NOT change.\");\r\n    process.exit(1);\r\n  }\r\n\r\n  // Cleanup\r\n  await prisma.user.delete({ where: { id: user.id } });\r\n  console.log(\"5. Cleanup complete.\");\r\n}\r\n\r\nmain()\r\n  .catch((e) => console.error(e))\r\n  .finally(async () => {\r\n    await prisma.$disconnect();\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\scripts\\verify_submission.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\seed-test-trip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\server-setup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\simple-launcher.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\smoke-test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\app.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for ./types/express.d.ts, use `import` style instead.","line":2,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":2,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\config\\cloudinary.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[680,683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[680,683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v2 as cloudinary } from \"cloudinary\";\r\nimport { CloudinaryStorage } from \"multer-storage-cloudinary\";\r\nimport multer from \"multer\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\n\r\nconst isTestMode = process.env.CLOUDINARY_API_KEY === \"123456789\" || !process.env.CLOUDINARY_CLOUD_NAME;\r\n\r\n// Ensure upload directories exist\r\nconst uploadDir = path.join(process.cwd(), \"uploads\");\r\nif (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir);\r\nconst imagesDir = path.join(uploadDir, \"images\");\r\nif (!fs.existsSync(imagesDir)) fs.mkdirSync(imagesDir);\r\nconst videosDir = path.join(uploadDir, \"videos\");\r\nif (!fs.existsSync(videosDir)) fs.mkdirSync(videosDir);\r\n\r\nlet storage: any;\r\n\r\nif (isTestMode) {\r\n  console.log(\"--> using LOCAL STORAGE for uploads <--\");\r\n  storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n      const isVideo = file.mimetype.startsWith(\"video/\");\r\n      cb(null, isVideo ? videosDir : imagesDir);\r\n    },\r\n    filename: (req, file, cb) => {\r\n      const uniqueSuffix = Date.now() + \"-\" + Math.round(Math.random() * 1e9);\r\n      const ext = path.extname(file.originalname);\r\n      cb(null, file.fieldname + \"-\" + uniqueSuffix + ext);\r\n    }\r\n  });\r\n} else {\r\n  if (!process.env.CLOUDINARY_CLOUD_NAME) {\r\n    throw new Error(\"CLOUDINARY_CLOUD_NAME is missing in env\");\r\n  }\r\n\r\n  cloudinary.config({\r\n    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n    api_key: process.env.CLOUDINARY_API_KEY,\r\n    api_secret: process.env.CLOUDINARY_API_SECRET,\r\n  });\r\n\r\n  storage = new CloudinaryStorage({\r\n    cloudinary: cloudinary,\r\n    params: async (req, file) => {\r\n      const isVideo = file.mimetype.startsWith(\"video/\");\r\n      return {\r\n        folder: isVideo ? \"param_adventures_uploads/videos\" : \"param_adventures_uploads/images\",\r\n        allowed_formats: [\"jpg\", \"png\", \"jpeg\", \"webp\", \"mp4\", \"webm\"],\r\n        public_id: file.fieldname + \"-\" + Date.now(),\r\n        resource_type: isVideo ? \"video\" : \"image\",\r\n        // Simplify to rule out Timeout/Processing errors\r\n        ...(isVideo ? {} : {\r\n           transformation: [{ quality: \"auto:good\", fetch_format: \"auto\" }]\r\n        }),\r\n      };\r\n    },\r\n  });\r\n}\r\n\r\nexport { cloudinary, storage };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\config\\env.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1660,1663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1660,1663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport \"dotenv/config.js\";\r\n\r\nconst envSchema = z.object({\r\n  PORT: z.string().default(\"3000\"),\r\n  NODE_ENV: z.enum([\"development\", \"test\", \"production\"]).default(\"development\"),\r\n\r\n  JWT_ACCESS_SECRET: z.string(),\r\n  JWT_REFRESH_SECRET: z.string(),\r\n\r\n  ACCESS_TOKEN_TTL: z.string().default(\"15m\"),\r\n  REFRESH_TOKEN_TTL: z.string().default(\"7d\"),\r\n\r\n  RAZORPAY_KEY_ID: z.string().default(\"rzp_test_placeholder\"),\r\n  RAZORPAY_KEY_SECRET: z.string().default(\"placeholder_secret\"),\r\n  RAZORPAY_WEBHOOK_SECRET: z.string().default(\"placeholder_webhook_secret\"),\r\n\r\n  // Redis\r\n  REDIS_URL: z.string().default(\"redis://localhost:6379\"),\r\n\r\n  // DB\r\n  DATABASE_URL: z.string(),\r\n\r\n  // Frontend\r\n  FRONTEND_URL: z.string().default(\"*\"),\r\n\r\n  // SMTP (Email)\r\n  SMTP_HOST: z.string().optional(),\r\n  SMTP_PORT: z.string().optional(),\r\n  SMTP_USER: z.string().optional(),\r\n  SMTP_PASS: z.string().optional(),\r\n  SMTP_FROM: z.string().default(\"Param Adventures <noreply@paramadventures.com>\"),\r\n\r\n  // OAuth\r\n  GOOGLE_CLIENT_ID: z.string().optional(),\r\n  GOOGLE_CLIENT_SECRET: z.string().optional(),\r\n});\r\n\r\nconst parsed = envSchema.safeParse(process.env);\r\n\r\nif (!parsed.success) {\r\n  console.error(\"❌ Invalid environment variables:\");\r\n  const fieldErrors = parsed.error.flatten().fieldErrors;\r\n  Object.entries(fieldErrors).forEach(([field, errors]) => {\r\n    console.error(`  - ${field}: ${errors?.join(\", \")}`);\r\n  });\r\n\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    console.warn(\"⚠️ Continuing in production despite invalid env - monitoring health...\");\r\n  }\r\n}\r\n\r\nexport const env = parsed.success ? parsed.data : (process.env as any);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\config\\passport.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[576,579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[576,579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[587,590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[587,590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[764,767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[764,767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1377,1380],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1377,1380],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1415,1418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1415,1418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1852,1855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1852,1855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport passport from \"passport\";\r\nimport { Strategy as GoogleStrategy } from \"passport-google-oauth20\";\r\nimport { prisma } from \"../lib/prisma\";\r\nimport { env } from \"./env\";\r\nimport { logger } from \"../lib/logger\";\r\n\r\nif (env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET) {\r\n  passport.use(\r\n    new GoogleStrategy(\r\n      {\r\n        clientID: env.GOOGLE_CLIENT_ID,\r\n        clientSecret: env.GOOGLE_CLIENT_SECRET,\r\n        callbackURL: \"/api/auth/google/callback\", // Proxied via Nginx or direct\r\n      },\r\n      async (accessToken: string, refreshToken: string, profile: any, done: any) => {\r\n        try {\r\n          // 1. Check if user exists by Google ID\r\n          let user = await prisma.user.findUnique({\r\n            where: { googleId: profile.id } as any,\r\n          });\r\n\r\n          if (user) {\r\n            return done(null, user);\r\n          }\r\n\r\n          // 2. Check if user exists by Email\r\n          const email = profile.emails?.[0]?.value;\r\n          if (email) {\r\n            user = await prisma.user.findUnique({\r\n              where: { email },\r\n            });\r\n\r\n            if (user) {\r\n              // Link Google Account\r\n              user = await prisma.user.update({\r\n                where: { id: user.id },\r\n                data: {\r\n                  googleId: profile.id,\r\n                  avatarUrl: profile.photos?.[0]?.value || (user as any).avatarUrl,\r\n                } as any,\r\n              });\r\n              return done(null, user);\r\n            }\r\n          }\r\n\r\n          // 3. Create New User\r\n          user = await prisma.user.create({\r\n            data: {\r\n              email: email!,\r\n              name: profile.displayName,\r\n              googleId: profile.id,\r\n              avatarUrl: profile.photos?.[0]?.value,\r\n              password: \"\", \r\n              status: \"ACTIVE\",\r\n            } as any,\r\n          });\r\n\r\n          return done(null, user);\r\n        } catch (error) {\r\n          logger.error(\"Google Auth Strategy Error\", error);\r\n          return done(error as Error, undefined);\r\n        }\r\n      },\r\n    ),\r\n  );\r\n} else {\r\n  logger.warn(\"Google OAuth credentials missing. Social login disabled.\");\r\n}\r\n\r\nexport default passport;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\config\\rate-limit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\config\\swagger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\analytics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\audit.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[316,319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[316,319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function listAuditLogs(req: Request, res: Response) {\r\n  const { action, actorId, targetType, page = 1, limit = 50 } = req.query;\r\n  const skip = (Number(page) - 1) * Number(limit);\r\n\r\n  try {\r\n    const where: any = {};\r\n    if (action) where.action = action;\r\n    if (actorId) where.actorId = actorId;\r\n    if (targetType) where.targetType = targetType;\r\n\r\n    const [logs, total] = await Promise.all([\r\n      prisma.auditLog.findMany({\r\n        where,\r\n        orderBy: { createdAt: \"desc\" },\r\n        skip,\r\n        take: Number(limit),\r\n        include: {\r\n          actor: {\r\n            select: {\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      }),\r\n      prisma.auditLog.count({ where }),\r\n    ]);\r\n\r\n    res.json({\r\n      logs,\r\n      pagination: {\r\n        total,\r\n        page: Number(page),\r\n        limit: Number(limit),\r\n        totalPages: Math.ceil(total / Number(limit)),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to list audit logs\", error);\r\n    res.status(500).json({ error: \"Internal server error\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\dashboard.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1371,1374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1371,1374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { analyticsService } from \"../../services/analytics.service\";\r\n\r\nexport async function getDashboardStats(req: Request, res: Response) {\r\n  try {\r\n    const [pendingBlogs, totalUsers, activeTrips, recentActivity, revenueStats] = await prisma\r\n      .$transaction([\r\n        // 1. Pending Blogs\r\n        prisma.blog.count({\r\n          where: { status: \"PENDING_REVIEW\" },\r\n        }),\r\n        // 2. Active Users\r\n        prisma.user.count({\r\n          where: { status: \"ACTIVE\" },\r\n        }),\r\n        // 3. Active/Published Trips\r\n        prisma.trip.count({\r\n          where: { status: \"PUBLISHED\" },\r\n        }),\r\n        // 4. Recent Audit Logs (Activity Stream)\r\n        prisma.auditLog.findMany({\r\n          take: 5,\r\n          orderBy: { createdAt: \"desc\" },\r\n          // Select only necessary fields for speed\r\n          select: {\r\n            id: true,\r\n            action: true,\r\n            createdAt: true,\r\n            targetType: true,\r\n          },\r\n        }),\r\n      ])\r\n      .then(async (results) => {\r\n        const rev = await analyticsService.getRevenueStats();\r\n        return [...results, rev];\r\n      });\r\n\r\n    res.json({\r\n      counts: {\r\n        pendingBlogs,\r\n        totalUsers,\r\n        activeTrips,\r\n        monthlyRevenue: (revenueStats as any).currentMonthRevenue,\r\n      },\r\n      recentActivity,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to fetch dashboard stats\", error);\r\n    res.status(500).json({ error: \"Failed to fetch dashboard stats\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\getGuideTrips.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[185,188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[185,188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function getGuideTrips(req: Request, res: Response) {\r\n  const userId = (req as any).user.id;\r\n\r\n  try {\r\n    const assignments = await prisma.tripsOnGuides.findMany({\r\n      where: { guideId: userId },\r\n      include: {\r\n        trip: {\r\n          include: {\r\n            coverImage: true,\r\n            bookings: {\r\n              where: { status: \"CONFIRMED\" },\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    name: true,\r\n                    phoneNumber: true,\r\n                    email: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n      orderBy: { trip: { startDate: \"asc\" } },\r\n    });\r\n\r\n    const trips = assignments.map((a) => ({\r\n      ...a.trip,\r\n      assignedAt: a.assignedAt,\r\n    }));\r\n\r\n    res.json(trips);\r\n  } catch (error) {\r\n    console.error(\"Failed to fetch guide trips\", error);\r\n    res.status(500).json({ error: \"Failed to fetch guide trips\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\getTripBookings.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\inquiry.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\listAllBookings.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\listTripBookings.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\role-assign.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[181,184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[181,184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function assignRole(req: Request, res: Response) {\r\n  const actor = (req as any).user;\r\n  const { userId, roleName } = req.body;\r\n\r\n  if (!actor || !actor.id) {\r\n    return res.status(401).json({ error: \"Unauthenticated\" });\r\n  }\r\n\r\n  // Rule 1: cannot modify self\r\n  if (actor.id === userId) {\r\n    return res.status(403).json({ error: \"Cannot modify your own roles\" });\r\n  }\r\n\r\n  const role = await prisma.role.findUnique({ where: { name: roleName } });\r\n  if (!role) return res.status(404).json({ error: \"Role not found\" });\r\n\r\n  // Rule 2 & 3: system roles only manageable by SUPER_ADMIN\r\n  if (role.isSystem && !(actor.roles || []).includes(\"SUPER_ADMIN\")) {\r\n    return res.status(403).json({ error: \"System role modification denied\" });\r\n  }\r\n\r\n  // Prevent duplicate assignment\r\n  await prisma.userRole.upsert({\r\n    where: { userId_roleId: { userId, roleId: role.id } },\r\n    update: {},\r\n    create: { userId, roleId: role.id },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: actor.id,\r\n      action: \"ROLE_ASSIGNED\",\r\n      targetType: \"User\",\r\n      targetId: userId,\r\n      metadata: { role: roleName },\r\n    },\r\n  });\r\n\r\n  res.json({ message: \"Role assigned\" });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\roles.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1849,1852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1849,1852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3070,3073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3070,3073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { isLastSuperAdmin } from \"../../utils/roleGuards\";\r\n\r\nexport async function listRoles(req: Request, res: Response) {\r\n  const roles = await prisma.role.findMany({\r\n    include: {\r\n      permissions: {\r\n        include: {\r\n          permission: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  res.json(\r\n    roles.map((r) => ({\r\n      id: r.id,\r\n      name: r.name,\r\n      isSystem: r.isSystem,\r\n      permissions: r.permissions.map((p) => p.permission.key),\r\n    })),\r\n  );\r\n}\r\n\r\nexport async function updateRolePermissions(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n  const { permissions } = req.body; // array of permission keys\r\n\r\n  if (!Array.isArray(permissions)) {\r\n    return res.status(400).json({ error: \"Permissions must be an array of strings\" });\r\n  }\r\n\r\n  const role = await prisma.role.findUnique({ where: { id } });\r\n  if (!role) {\r\n    return res.status(404).json({ error: \"Role not found\" });\r\n  }\r\n\r\n  if (role.isSystem) {\r\n    return res.status(403).json({ error: \"Cannot modify system roles\" });\r\n  }\r\n\r\n  // Find all permission IDs for the keys\r\n  const permissionRecs = await prisma.permission.findMany({\r\n    where: { key: { in: permissions } },\r\n  });\r\n\r\n  // Transaction to replace permissions\r\n  await prisma.$transaction(async (tx) => {\r\n    // 1. Remove all existing\r\n    await tx.rolePermission.deleteMany({ where: { roleId: id } });\r\n\r\n    // 2. Add new\r\n    if (permissionRecs.length > 0) {\r\n      await tx.rolePermission.createMany({\r\n        data: permissionRecs.map((p) => ({\r\n          roleId: id,\r\n          permissionId: p.id,\r\n        })),\r\n      });\r\n    }\r\n  });\r\n\r\n  res.json({ success: true });\r\n}\r\n\r\nexport async function assignRole(req: Request, res: Response) {\r\n  const actor = (req as any).user;\r\n  const { userId, roleName } = req.body;\r\n\r\n  if (!actor || !actor.id) {\r\n    return res.status(401).json({ error: \"Unauthenticated\" });\r\n  }\r\n\r\n  // Rule 1: cannot modify self\r\n  if (actor.id === userId) {\r\n    return res.status(403).json({ error: \"Cannot modify your own roles\" });\r\n  }\r\n\r\n  const role = await prisma.role.findUnique({ where: { name: roleName } });\r\n  if (!role) return res.status(404).json({ error: \"Role not found\" });\r\n\r\n  // Rule 2 & 3: system roles only manageable by SUPER_ADMIN\r\n  if (role.isSystem && !(actor.roles || []).includes(\"SUPER_ADMIN\")) {\r\n    return res.status(403).json({ error: \"System role modification denied\" });\r\n  }\r\n\r\n  // Prevent duplicate assignment\r\n  await prisma.userRole.upsert({\r\n    where: { userId_roleId: { userId, roleId: role.id } },\r\n    update: {},\r\n    create: { userId, roleId: role.id },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: actor.id,\r\n      action: \"ROLE_ASSIGNED\",\r\n      targetType: \"User\",\r\n      targetId: userId,\r\n      metadata: { role: roleName },\r\n    },\r\n  });\r\n\r\n  res.json({ message: \"Role assigned\" });\r\n}\r\n\r\nexport async function revokeRole(req: Request, res: Response) {\r\n  const actor = (req as any).user;\r\n  const { userId, roleName } = req.body;\r\n\r\n  if (!actor || !actor.id) {\r\n    return res.status(401).json({ error: \"Unauthenticated\" });\r\n  }\r\n\r\n  // Rule 1: cannot modify self\r\n  if (actor.id === userId) {\r\n    return res.status(403).json({ error: \"Cannot modify your own roles\" });\r\n  }\r\n\r\n  const role = await prisma.role.findUnique({ where: { name: roleName } });\r\n  if (!role) return res.status(404).json({ error: \"Role not found\" });\r\n\r\n  // Rule 4: cannot remove last SUPER_ADMIN\r\n  if (role.name === \"SUPER_ADMIN\" && (await isLastSuperAdmin(userId))) {\r\n    return res.status(403).json({ error: \"Cannot remove last SUPER_ADMIN\" });\r\n  }\r\n\r\n  // Rule 2 & 3\r\n  if (role.isSystem && !(actor.roles || []).includes(\"SUPER_ADMIN\")) {\r\n    return res.status(403).json({ error: \"System role modification denied\" });\r\n  }\r\n\r\n  await prisma.userRole.delete({\r\n    where: { userId_roleId: { userId, roleId: role.id } },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: actor.id,\r\n      action: \"ROLE_REVOKED\",\r\n      targetType: \"User\",\r\n      targetId: userId,\r\n      metadata: { role: roleName },\r\n    },\r\n  });\r\n\r\n  res.json({ message: \"Role revoked\" });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\trip-assignment.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1881,1884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1881,1884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3608,3611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3608,3611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { logger } from \"../../lib/logger\";\r\nimport { notificationQueue } from \"../../lib/queue\";\r\n\r\nexport async function assignManager(req: Request, res: Response) {\r\n  const { tripId } = req.params;\r\n  const { managerId } = req.body;\r\n\r\n  if (!managerId) {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"managerId is required\");\r\n  }\r\n\r\n  // Verify trip exists\r\n  const trip = await prisma.trip.findUnique({ where: { id: tripId } });\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  // Verify manager has the correct role\r\n  const manager = await prisma.user.findUnique({\r\n    where: { id: managerId },\r\n    include: { roles: { include: { role: true } } },\r\n  });\r\n\r\n  if (!manager || !manager.roles.some((r) => r.role.name === \"TRIP_MANAGER\")) {\r\n    throw new HttpError(400, \"INVALID_ROLE\", \"User does not have TRIP_MANAGER role\");\r\n  }\r\n\r\n  const updatedTrip = await prisma.trip.update({\r\n    where: { id: tripId },\r\n    data: { managerId },\r\n    include: { manager: { select: { id: true, name: true, email: true } } },\r\n  });\r\n\r\n  logger.info(\"Manager assigned to trip\", { tripId, managerId });\r\n\r\n  // Send Notification (Async - Fire & Forget to prevent hanging if Redis is slow)\r\n  notificationQueue.add(\"SEND_ASSIGNMENT_EMAIL\", {\r\n    userId: managerId,\r\n    role: \"TRIP_MANAGER\",\r\n    details: {\r\n      tripTitle: trip.title,\r\n    },\r\n  }).catch((err) => {\r\n    logger.error(\"Failed to queue assignment email\", { error: err });\r\n  });\r\n\r\n  res.json({ success: true, trip: updatedTrip });\r\n}\r\n\r\nexport async function assignGuide(req: Request, res: Response) {\r\n  const { tripId } = req.params;\r\n  const { guideId } = req.body;\r\n  const userId = req.user!.id;\r\n  const userRoles = (req as any).roles || [];\r\n\r\n  if (!guideId) {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"guideId is required\");\r\n  }\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id: tripId } });\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  // Authorization check: Only Admin or the assigned Manager can assign guides\r\n  const isAdmin = userRoles.includes(\"ADMIN\") || userRoles.includes(\"SUPER_ADMIN\");\r\n  const isAssignedManager = trip.managerId === userId;\r\n\r\n  if (!isAdmin && !isAssignedManager) {\r\n    throw new HttpError(403, \"FORBIDDEN\", \"You are not authorized to assign guides to this trip\");\r\n  }\r\n\r\n  // Verify guide has the correct role\r\n  const guide = await prisma.user.findUnique({\r\n    where: { id: guideId },\r\n    include: { roles: { include: { role: true } } },\r\n  });\r\n\r\n  if (!guide || !guide.roles.some((r) => r.role.name === \"TRIP_GUIDE\")) {\r\n    throw new HttpError(400, \"INVALID_ROLE\", \"User does not have TRIP_GUIDE role\");\r\n  }\r\n\r\n  // Add to many-to-many relation\r\n  await prisma.tripsOnGuides.upsert({\r\n    where: {\r\n      tripId_guideId: { tripId, guideId },\r\n    },\r\n    update: {},\r\n    create: { tripId, guideId },\r\n  });\r\n\r\n  logger.info(\"Guide assigned to trip\", { tripId, guideId, assignedBy: userId });\r\n\r\n  // Send Notification (Async)\r\n  await notificationQueue.add(\"SEND_ASSIGNMENT_EMAIL\", {\r\n    userId: guideId,\r\n    role: \"TRIP_GUIDE\",\r\n    details: {\r\n      tripTitle: trip.title,\r\n    },\r\n  });\r\n\r\n  res.json({ success: true, message: \"Guide assigned successfully\" });\r\n}\r\n\r\nexport async function removeGuide(req: Request, res: Response) {\r\n  const { tripId, guideId } = req.params;\r\n  const userId = req.user!.id;\r\n  const userRoles = (req as any).roles || [];\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id: tripId } });\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  const isAdmin = userRoles.includes(\"ADMIN\") || userRoles.includes(\"SUPER_ADMIN\");\r\n  const isAssignedManager = trip.managerId === userId;\r\n\r\n  if (!isAdmin && !isAssignedManager) {\r\n    throw new HttpError(403, \"FORBIDDEN\", \"You are not authorized to remove guides from this trip\");\r\n  }\r\n\r\n  await prisma.tripsOnGuides.delete({\r\n    where: {\r\n      tripId_guideId: { tripId, guideId },\r\n    },\r\n  });\r\n\r\n  logger.info(\"Guide removed from trip\", { tripId, guideId, removedBy: userId });\r\n  res.json({ success: true, message: \"Guide removed successfully\" });\r\n}\r\n\r\nexport async function listEligibleUsers(req: Request, res: Response) {\r\n  const { role } = req.query; // 'TRIP_MANAGER' or 'TRIP_GUIDE'\r\n\r\n  if (!role || typeof role !== \"string\") {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"role query parameter is required\");\r\n  }\r\n\r\n  const users = await prisma.user.findMany({\r\n    where: {\r\n      roles: {\r\n        some: {\r\n          role: { name: role },\r\n        },\r\n      },\r\n    },\r\n    select: {\r\n      id: true,\r\n      name: true,\r\n      email: true,\r\n      nickname: true,\r\n    },\r\n  });\r\n\r\n  res.json(users);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\admin\\users.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[204,207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[204,207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2116,2119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2116,2119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2645,2648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2645,2648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function listUsers(req: Request, res: Response) {\r\n  const { role } = req.query;\r\n\r\n  const where: any = {};\r\n\r\n  if (role) {\r\n    where.roles = {\r\n      some: {\r\n        role: {\r\n          name: String(role),\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n  const users = await prisma.user.findMany({\r\n    where,\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      name: true,\r\n      status: true,\r\n      createdAt: true,\r\n      avatarImage: {\r\n        select: {\r\n          thumbUrl: true,\r\n        },\r\n      },\r\n      roles: {\r\n        include: {\r\n          role: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  res.json(\r\n    users.map((u) => ({\r\n      id: u.id,\r\n      email: u.email,\r\n      name: u.name,\r\n      status: u.status,\r\n      roles: u.roles.map((r) => r.role.name),\r\n      createdAt: u.createdAt,\r\n      avatarImage: u.avatarImage,\r\n    })),\r\n  );\r\n}\r\nexport async function updateUserStatus(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n  const { status, reason } = req.body;\r\n\r\n  if (![\"ACTIVE\", \"SUSPENDED\", \"BANNED\"].includes(status)) {\r\n    return res.status(400).json({ error: \"Invalid status\" });\r\n  }\r\n\r\n  const user = await prisma.user.update({\r\n    where: { id },\r\n    data: {\r\n      status,\r\n      statusReason: reason,\r\n    },\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      status: true,\r\n    },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: (req as any).user.id,\r\n      action: \"USER_STATUS_UPDATED\",\r\n      targetType: \"USER\",\r\n      targetId: user.id,\r\n      metadata: { status, reason },\r\n    },\r\n  });\r\n\r\n  res.json(user);\r\n}\r\n\r\nexport async function deleteUser(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n\r\n  // Soft delete via status (Using BANNED as proxy for DELETE to avoid schema lock issues)\r\n  const user = await prisma.user.update({\r\n    where: { id },\r\n    data: { status: \"BANNED\", statusReason: \"DELETED_BY_ADMIN\" },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: (req as any).user.id,\r\n      action: \"USER_DELETED\",\r\n      targetType: \"USER\",\r\n      targetId: user.id,\r\n      metadata: { deletedAt: new Date().toISOString() },\r\n    },\r\n  });\r\n\r\n  res.json({ message: \"User deleted successfully\" });\r\n}\r\n\r\nexport async function unsuspendUser(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n\r\n  const user = await prisma.user.update({\r\n    where: { id },\r\n    data: { status: \"ACTIVE\", statusReason: null },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: (req as any).user.id,\r\n      action: \"USER_UNSUSPENDED\",\r\n      targetType: \"USER\",\r\n      targetId: user.id,\r\n    },\r\n  });\r\n\r\n  res.json(user);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\auth.controller.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3481,3484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3481,3484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5380,5383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5380,5383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5721,5724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5721,5724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\approveBlog.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\createBlog.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[361,364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[361,364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { slugify } from \"../../utils/slugify\";\r\nimport { auditService } from \"../../services/audit.service\";\r\n\r\nexport async function createBlog(req: Request, res: Response) {\r\n  const { title, content, excerpt, tripId, coverImageId } = req.body;\r\n  const user = (req as any).user;\r\n\r\n  const slug = slugify(title);\r\n\r\n  if (!tripId) {\r\n    return res.status(400).json({ message: \"Blogs must be linked to a completed adventure.\" });\r\n  }\r\n\r\n  if (tripId) {\r\n    const booking = await prisma.booking.findFirst({\r\n      where: {\r\n        userId: user.id,\r\n        tripId: tripId,\r\n        status: \"COMPLETED\",\r\n      },\r\n    });\r\n\r\n    if (!booking) {\r\n      return res\r\n        .status(403)\r\n        .json({ message: \"You can only write blogs for trips you have completed.\" });\r\n    }\r\n  }\r\n\r\n  const blog = await prisma.blog.create({\r\n    data: {\r\n      title,\r\n      slug,\r\n      content,\r\n      excerpt,\r\n      tripId,\r\n      coverImageId,\r\n      authorId: user.id,\r\n    },\r\n  });\r\n\r\n  await auditService.logAudit({\r\n    actorId: user.id,\r\n    action: \"BLOG_CREATED\",\r\n    targetType: \"BLOG\",\r\n    targetId: blog.id,\r\n    metadata: { status: blog.status },\r\n  });\r\n\r\n  res.status(201).json(blog);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\getBlogById.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[507,510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[507,510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function getBlogById(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n  // Assuming req.user is added by a middleware like requireAuth\r\n  // and Request type is augmented or casted elsewhere if not using AuthRequest directly.\r\n  // For this change, we'll assume req.user is available on Request after middleware.\r\n  const user = (req as any).user;\r\n\r\n  const blog = await prisma.blog.findUnique({\r\n    where: { id },\r\n    include: {\r\n      author: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n        },\r\n      },\r\n      coverImage: true,\r\n      trip: {\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          slug: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!blog) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Blog not found\");\r\n  }\r\n\r\n  // Check if user is author OR has admin permission\r\n  const isAuthor = blog.authorId === user?.id;\r\n  const isAdmin = user?.permissions.includes(\"blog:approve\");\r\n\r\n  if (!isAuthor && !isAdmin) {\r\n    throw new HttpError(403, \"FORBIDDEN\", \"You do not have permission to view this blog\");\r\n  }\r\n\r\n  res.json(blog);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\getBlogBySlug.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[494,497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[494,497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function getBlogBySlug(req: Request, res: Response) {\r\n  const { slug } = req.params;\r\n  const user = req.user; // Types verified in express.d.ts\r\n  const permissions = req.permissions || [];\r\n\r\n  const canViewInternal =\r\n    permissions.includes(\"blog:approve\") || permissions.includes(\"blog:view:internal\");\r\n\r\n  const whereCondition: any = { slug };\r\n\r\n  if (!canViewInternal) {\r\n    if (user) {\r\n      // Allow if PUBLISHED or if the user is the author\r\n      whereCondition.OR = [{ status: \"PUBLISHED\" }, { authorId: user.id }];\r\n    } else {\r\n      whereCondition.status = \"PUBLISHED\";\r\n    }\r\n  }\r\n\r\n  const blog = await prisma.blog.findFirst({\r\n    // where: whereCondition,\r\n    where: whereCondition,\r\n    include: {\r\n      author: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n        },\r\n      },\r\n      coverImage: true,\r\n      trip: {\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          slug: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!blog) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Blog not found\");\r\n  }\r\n\r\n  res.json(blog);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\getBlogs.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[276,279],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[276,279],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function getBlogs(req: Request, res: Response) {\r\n  const { status } = req.query;\r\n\r\n  const blogs = await prisma.blog.findMany({\r\n    where: status ? { status: status as any } : undefined,\r\n    include: {\r\n      author: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n        },\r\n      },\r\n      coverImage: true,\r\n    },\r\n    orderBy: { createdAt: \"desc\" },\r\n  });\r\n\r\n  res.json(blogs);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\getMyBlogs.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\getPublicBlogs.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[335,338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[335,338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const getPublicBlogs = catchAsync(async (req: Request, res: Response) => {\r\n  const { search } = req.query;\r\n\r\n  const where: any = { status: \"PUBLISHED\" };\r\n\r\n  if (search) {\r\n    where.OR = [\r\n      { title: { search: String(search).split(\" \").join(\" & \") } },\r\n      { excerpt: { search: String(search).split(\" \").join(\" & \") } },\r\n    ];\r\n  }\r\n\r\n  const blogs = await prisma.blog.findMany({\r\n    where,\r\n    orderBy: { createdAt: \"desc\" },\r\n    include: {\r\n      author: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n        },\r\n      },\r\n      coverImage: true,\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Blogs fetched\", blogs);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\publishBlog.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\rejectBlog.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\submitBlog.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\blogs\\updateBlog.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[781,784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[781,784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { slugify } from \"../../utils/slugify\";\r\nimport { auditService } from \"../../services/audit.service\";\r\n\r\nexport async function updateBlog(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n  const user = req.user!;\r\n  const { title, content, excerpt, tripId, coverImageId } = req.body;\r\n\r\n  const blog = await prisma.blog.findUnique({ where: { id } });\r\n\r\n  if (!blog || blog.authorId !== user.id) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Blog not found\");\r\n  }\r\n\r\n  // if (blog.status === \"ARCHIVED\") {\r\n  //   throw new HttpError(403, \"INVALID_STATE\", \"Cannot edit archived blogs\");\r\n  // }\r\n\r\n  const updateData: any = {\r\n    title,\r\n    content,\r\n    excerpt,\r\n    tripId,\r\n    coverImageId,\r\n    updatedAt: new Date(),\r\n  };\r\n\r\n  // If editing an approved or published blog, revert to pending review\r\n  if ([\"APPROVED\", \"PUBLISHED\"].includes(blog.status)) {\r\n    updateData.status = \"PENDING_REVIEW\";\r\n  }\r\n\r\n  if (title && title !== blog.title) {\r\n    updateData.slug = slugify(title);\r\n  }\r\n\r\n  const updated = await prisma.blog.update({\r\n    where: { id },\r\n    data: updateData,\r\n  });\r\n\r\n  await auditService.logAudit({\r\n    actorId: user.id,\r\n    action: \"BLOG_UPDATED\",\r\n    targetType: \"BLOG\",\r\n    targetId: blog.id,\r\n  });\r\n\r\n  res.json(updated);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\approveBooking.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[321,324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[321,324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[824,827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[824,827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { assertBookingTransition } from \"../../domain/booking/bookingTransitions\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function approveBooking(req: Request, res: Response) {\r\n  const admin = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  try {\r\n    const updated = await prisma.$transaction(async (tx) => {\r\n      const booking = await tx.booking.findUnique({ where: { id } });\r\n      if (!booking) throw new HttpError(404, \"NOT_FOUND\", \"Booking not found\");\r\n\r\n      if (booking.status === \"CONFIRMED\" || booking.status === \"REJECTED\") {\r\n        throw new HttpError(403, \"INVALID_STATE\", \"Booking already processed\");\r\n      }\r\n\r\n      try {\r\n        assertBookingTransition(booking.status as any, \"approve\");\r\n      } catch {\r\n        throw new HttpError(\r\n          403,\r\n          \"INVALID_BOOKING_TRANSITION\",\r\n          \"Booking cannot be approved in its current state\",\r\n        );\r\n      }\r\n\r\n      const confirmedCount = await tx.booking.count({\r\n        where: { tripId: booking.tripId, status: \"CONFIRMED\" },\r\n      });\r\n\r\n      const trip = await tx.trip.findUnique({ where: { id: booking.tripId } });\r\n      if (!trip) throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n\r\n      if (confirmedCount >= trip.capacity) {\r\n        await tx.auditLog.create({\r\n          data: {\r\n            actorId: admin.id,\r\n            action: \"BOOKING_REJECTED_CAPACITY\",\r\n            targetType: \"BOOKING\",\r\n            targetId: booking.id,\r\n            metadata: { tripId: booking.tripId },\r\n          },\r\n        });\r\n        throw new HttpError(409, \"CAPACITY_FULL\", \"Trip capacity is full\");\r\n      }\r\n\r\n      const updated = await tx.booking.update({\r\n        where: { id },\r\n        data: { status: \"CONFIRMED\" },\r\n      });\r\n\r\n      await tx.auditLog.create({\r\n        data: {\r\n          actorId: admin.id,\r\n          action: \"BOOKING_CONFIRMED\",\r\n          targetType: \"BOOKING\",\r\n          targetId: booking.id,\r\n          metadata: { tripId: booking.tripId },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    });\r\n\r\n    return res.json(updated);\r\n  } catch (err) {\r\n    if (err instanceof HttpError) throw err;\r\n    throw new HttpError(500, \"INTERNAL_ERROR\", \"Internal Server Error\");\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\cancelBooking.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\createBooking.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\getBookingById.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[375,378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[375,378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { bookingService } from \"../../services/booking.service\";\r\n\r\nexport const getBookingById = async (req: Request, res: Response) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const userId = req.user!.id;\r\n\r\n    const booking = await bookingService.getBookingById(id, userId);\r\n    res.json(booking);\r\n  } catch (error: any) {\r\n    const status = error.message.includes(\"not found\")\r\n      ? 404\r\n      : error.message.includes(\"Unauthorized\")\r\n        ? 403\r\n        : 500;\r\n    res.status(status).json({ error: error.message });\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\getBookings.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\getMyBookings.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[218,221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[218,221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { bookingService } from \"../../services/booking.service\";\r\n\r\nexport async function getMyBookings(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.id;\r\n    const bookings = await bookingService.getMyBookings(userId);\r\n    res.json(bookings);\r\n  } catch {\r\n    res.status(500).json({ error: \"Failed to load bookings\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\bookings\\rejectBooking.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[320,323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[320,323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[750,753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[750,753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1357,1360],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1357,1360],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { assertBookingTransition } from \"../../domain/booking/bookingTransitions\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function rejectBooking(req: Request, res: Response) {\r\n  const admin = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  try {\r\n    const booking = await prisma.booking.findUnique({ where: { id } });\r\n    if (!booking) throw new HttpError(404, \"NOT_FOUND\", \"Booking not found\");\r\n\r\n    if (booking.status === \"CONFIRMED\" || booking.status === \"REJECTED\") {\r\n      throw new HttpError(403, \"INVALID_STATE\", \"Booking already processed\");\r\n    }\r\n\r\n    try {\r\n      assertBookingTransition(booking.status as any, \"reject\");\r\n    } catch {\r\n      throw new HttpError(\r\n        403,\r\n        \"INVALID_BOOKING_TRANSITION\",\r\n        \"Booking cannot be rejected in its current state\",\r\n      );\r\n    }\r\n\r\n    const updated = await prisma.booking.update({\r\n      where: { id },\r\n      data: { status: \"REJECTED\" },\r\n    });\r\n\r\n    await prisma.auditLog.create({\r\n      data: {\r\n        actorId: admin.id,\r\n        action: \"BOOKING_REJECTED\",\r\n        targetType: \"BOOKING\",\r\n        targetId: booking.id,\r\n        metadata: { tripId: booking.tripId },\r\n      },\r\n    });\r\n\r\n    return res.json(updated);\r\n  } catch (err: any) {\r\n    if (err instanceof HttpError) throw err;\r\n    throw new HttpError(500, \"INTERNAL_ERROR\", \"Internal Server Error\");\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\content\\heroSlide.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\content\\stats.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\health.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\inquiry.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\mediaUpload.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[388,391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[388,391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2576,2579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2576,2579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../lib/prisma\";\r\nimport { catchAsync } from \"../utils/catchAsync\";\r\nimport { ApiResponse } from \"../utils/ApiResponse\";\r\n\r\nexport const uploadImage = catchAsync(async (req: Request, res: Response) => {\r\n  if (!req.file) {\r\n    return ApiResponse.error(res, \"NO_FILE_UPLOADED\", 400);\r\n  }\r\n\r\n  const file = req.file as any; // Multer Cloudinary File\r\n\r\n  // Construct URLs using the Cloudinary response\r\n  let originalUrl = file.path;\r\n  let mediumUrl = file.path;\r\n  let thumbUrl = file.path;\r\n\r\n  // If Image, generate variants by URL string manipulation (basic)\r\n  // or use the ones we might want to store explicitly?\r\n  // Ideally we store the ID or Base URL. For now, let's just use the Secure URL.\r\n  // We can apply transformations on the fly in Frontend or here.\r\n\r\n  // Handle Local Storage vs Cloudinary\r\n  if (file.path && !file.path.startsWith(\"http\")) {\r\n    // It's local path: C:\\Users\\...\\uploads\\images\\filename.jpg\r\n    // Convert to URL: http://localhost:3001/uploads/images/filename.jpg\r\n    const filename = file.filename;\r\n    const folder = file.mimetype.startsWith(\"video/\") ? \"videos\" : \"images\";\r\n    const localUrl = `${process.env.API_URL || \"http://localhost:3001\"}/uploads/${folder}/${filename}`;\r\n\r\n    originalUrl = localUrl;\r\n    mediumUrl = localUrl;\r\n    thumbUrl = localUrl;\r\n  } else if (file.mimetype.startsWith(\"image/\")) {\r\n    // Cloudinary URL format: .../upload/{transformations}/v{version}/{id}\r\n    // We can just store the base secure_url.\r\n    // Or mimic old behavior:\r\n    thumbUrl = file.path.replace(\"/upload/\", \"/upload/c_fill,w_400,h_400/\");\r\n    mediumUrl = file.path.replace(\"/upload/\", \"/upload/c_limit,w_1200/\");\r\n  } else if (file.mimetype.startsWith(\"video/\")) {\r\n    // Video Optimization on Delivery (q_auto, f_auto)\r\n    // This ensures fast upload (raw) but optimized playback\r\n    const uploadPath = \"/upload/\";\r\n    const optimizedPath = \"/upload/q_auto:good,f_auto,c_limit,w_1280/\";\r\n\r\n    mediumUrl = file.path.replace(uploadPath, optimizedPath);\r\n    thumbUrl = file.path.replace(uploadPath, optimizedPath).replace(/\\.[^/.]+$/, \".jpg\");\r\n  }\r\n\r\n  const image = await prisma.image.create({\r\n    data: {\r\n      originalUrl,\r\n      mediumUrl: mediumUrl,\r\n      thumbUrl: thumbUrl,\r\n      width: file.width || 0,\r\n      height: file.height || 0,\r\n      size: file.size,\r\n      mimeType: file.mimetype,\r\n      type: file.mimetype.startsWith(\"video/\") ? \"VIDEO\" : \"IMAGE\",\r\n      duration: file.duration || 0,\r\n      uploadedById: (req.user as any).id,\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"File uploaded successfully\", { image }, 201);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\addTripGalleryImage.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\listMedia.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[289,292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[289,292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1728,1731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1728,1731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\n\r\nexport async function listMedia(req: Request, res: Response) {\r\n  const { type, page = 1, limit = 50 } = req.query;\r\n  const skip = (Number(page) - 1) * Number(limit);\r\n\r\n  try {\r\n    const where: any = {};\r\n    if (type && type !== \"ALL\") {\r\n      where.type = type;\r\n    }\r\n\r\n    const [mediaItems, total] = await Promise.all([\r\n      prisma.image.findMany({\r\n        where,\r\n        orderBy: { createdAt: \"desc\" },\r\n        skip,\r\n        take: Number(limit),\r\n        include: {\r\n          _count: {\r\n            select: {\r\n              tripsCover: true,\r\n              blogsCover: true,\r\n              userAvatar: true,\r\n              tripsGallery: true,\r\n            },\r\n          },\r\n        },\r\n      }),\r\n      prisma.image.count({ where }),\r\n    ]);\r\n\r\n    const media = mediaItems.map((item) => ({\r\n      ...item,\r\n      usage: {\r\n        trips: item._count.tripsCover + item._count.tripsGallery,\r\n        blogs: item._count.blogsCover,\r\n        users: item._count.userAvatar,\r\n      },\r\n    }));\r\n\r\n    res.json({\r\n      media,\r\n      pagination: {\r\n        total,\r\n        page: Number(page),\r\n        limit: Number(limit),\r\n        totalPages: Math.ceil(total / Number(limit)),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to list media\", error);\r\n    res.status(500).json({ error: \"Internal server error\" });\r\n  }\r\n}\r\n\r\nexport async function deleteMedia(req: Request, res: Response) {\r\n  const { id } = req.params;\r\n  try {\r\n    await prisma.image.delete({\r\n      where: { id },\r\n    });\r\n    // TODO: Delete actual file from disk to save space\r\n    res.json({ success: true });\r\n  } catch (error: any) {\r\n    console.error(\"Delete media error:\", error);\r\n    if (error.code === \"P2003\") {\r\n      return res.status(400).json({\r\n        error: \"Cannot delete media because it is being used by other records (Trips/Blogs/Users).\",\r\n      });\r\n    }\r\n    if (error.code === \"P2025\") {\r\n      return res.status(404).json({ error: \"Media not found.\" });\r\n    }\r\n    res.status(500).json({ error: \"Failed to delete media\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\setTripCoverImage.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\setTripGallery.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\uploadDocument.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1102,1105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1102,1105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport path from \"path\";\r\nimport fs from \"fs/promises\";\r\nimport crypto from \"crypto\";\r\n\r\nconst UPLOAD_DIR = path.join(process.cwd(), \"uploads\");\r\n\r\nexport async function uploadDocument(req: Request, res: Response) {\r\n  if (!req.file) {\r\n    return res.status(400).json({ error: \"NO_FILE_UPLOADED\" });\r\n  }\r\n\r\n  try {\r\n    // Ensure documents directory exists\r\n    const docDir = path.join(UPLOAD_DIR, \"documents\");\r\n    await fs.mkdir(docDir, { recursive: true });\r\n\r\n    // Generate unique filename\r\n    const id = crypto.randomUUID();\r\n    const originalName = req.file.originalname.replace(/[^a-zA-Z0-9.-]/g, \"_\"); // Sanitize\r\n    const filename = `${id}_${originalName}`;\r\n    const filePath = path.join(docDir, filename);\r\n\r\n    // Save file\r\n    await fs.writeFile(filePath, req.file.buffer);\r\n\r\n    // Construct public URL\r\n    // Assuming 'uploads' is served statically via /uploads\r\n    const url = `/uploads/documents/${filename}`;\r\n\r\n    res.status(201).json({\r\n      url,\r\n      filename,\r\n      size: req.file.size,\r\n    });\r\n  } catch (err: any) {\r\n    console.error(\"Document Upload Error:\", err);\r\n    res.status(500).json({\r\n      error: \"UPLOAD_FAILED\",\r\n      details: err.message,\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\uploadTripCover.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[365,368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[365,368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1015,1018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1015,1018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function uploadTripCover(req: Request, res: Response) {\r\n  if (!req.file) {\r\n    throw new HttpError(400, \"NO_FILE\", \"No image uploaded\");\r\n  }\r\n\r\n  const { tripId } = req.params;\r\n  const file = req.file as any; // Cloudinary File\r\n\r\n  // Construct URLs\r\n  const originalUrl = file.path;\r\n  // Apply Cloudinary transformations for display versions\r\n  const mediumUrl = file.path.replace(\"/upload/\", \"/upload/c_limit,w_1200/\");\r\n  const thumbUrl = file.path.replace(\"/upload/\", \"/upload/c_fill,w_800,h_500/\"); // 16:10 aspect roughly\r\n\r\n  // Create Image record\r\n  const image = await prisma.image.create({\r\n    data: {\r\n      originalUrl: originalUrl,\r\n      mediumUrl: mediumUrl,\r\n      thumbUrl: thumbUrl,\r\n      mimeType: file.mimetype,\r\n      size: file.size,\r\n      width: file.width || 0,\r\n      height: file.height || 0,\r\n      uploadedById: (req as any).user.id,\r\n      type: \"IMAGE\",\r\n      duration: 0,\r\n    },\r\n  });\r\n\r\n  // Update Trip\r\n  await prisma.trip.update({\r\n    where: { id: tripId },\r\n    data: {\r\n      coverImageId: image.id,\r\n    },\r\n  });\r\n\r\n  res.status(201).json({\r\n    image: originalUrl,\r\n    imageId: image.id,\r\n    urls: {\r\n      original: originalUrl,\r\n      medium: mediumUrl,\r\n      thumb: thumbUrl,\r\n    },\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\media\\uploadTripGallery.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[484,487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[484,487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[519,522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[519,522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[600,603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[600,603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2098,2101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2098,2101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { processMedia } from \"../../utils/mediaProcessor\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport async function uploadTripGallery(req: Request, res: Response) {\r\n  if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {\r\n    throw new HttpError(400, \"NO_FILES\", \"No images uploaded\");\r\n  }\r\n\r\n  const { tripId } = req.params;\r\n  const processedResults: any[] = [];\r\n  const imageRecords: any[] = [];\r\n\r\n  // Parallel processing\r\n  await Promise.all(\r\n    (req.files as any[]).map(async (file) => {\r\n      // Case 1: Video (Uploaded via CloudinaryStorage)\r\n      if (file.path && file.path.includes(\"cloudinary\")) {\r\n        // It's already uploaded. We just need to map it to our schema.\r\n        processedResults.push({\r\n          originalUrl: file.path, // Secure URL\r\n          mediumUrl: file.path, \r\n          thumbUrl: file.path.replace(/\\.[^/.]+$/, \".jpg\"), // Video -> Image thumb\r\n          mimeType: file.mimetype,\r\n          size: file.size,\r\n          width: 0, // Metadata might be in file object, or skipped\r\n          height: 0,\r\n          type: \"VIDEO\",\r\n          duration: 0,\r\n        });\r\n      } \r\n      // Case 2: Image (Buffer from MemoryStorage)\r\n      else if (file.buffer) {\r\n        const result = await processMedia(file.buffer, file.mimetype);\r\n        processedResults.push(result);\r\n      }\r\n    }),\r\n  );\r\n\r\n  // Calculate starting order index\r\n  const lastImage = await prisma.tripGalleryImage.findFirst({\r\n    where: { tripId },\r\n    orderBy: { order: \"desc\" },\r\n  });\r\n  let nextOrder = lastImage ? lastImage.order + 1 : 0;\r\n\r\n  // Database operations\r\n  for (const result of processedResults) {\r\n    const image = await prisma.image.create({\r\n      data: {\r\n        originalUrl: result.originalUrl,\r\n        mediumUrl: result.mediumUrl,\r\n        thumbUrl: result.thumbUrl,\r\n        mimeType: result.mimeType,\r\n        size: result.size,\r\n        width: result.width,\r\n\r\n        height: result.height,\r\n        uploadedById: (req as any).user.id,\r\n        type: result.type,\r\n        duration: result.duration || 0,\r\n        tripsGallery: {\r\n          create: {\r\n            tripId,\r\n            order: nextOrder++,\r\n          },\r\n        },\r\n      },\r\n    });\r\n    imageRecords.push(image);\r\n  }\r\n\r\n  res.status(201).json({\r\n    images: imageRecords,\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\newsletter.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\paymentEvents.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[154,157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[154,157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1415,1418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1415,1418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2643,2646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2643,2646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from \"../lib/prisma\";\r\nimport { logWebhookReplay } from \"../utils/webhookLogger\";\r\n\r\nexport async function handlePaymentCaptured(event: any) {\r\n  const paymentEntity = event.payload?.payment?.entity;\r\n  const razorpayPaymentId = paymentEntity?.id;\r\n  const razorpayOrderId = paymentEntity?.order_id;\r\n\r\n  if (!razorpayOrderId) return;\r\n\r\n  const payment = await prisma.payment.findUnique({\r\n    where: { providerOrderId: razorpayOrderId },\r\n  });\r\n\r\n  if (!payment) return;\r\n\r\n  if (payment.status === \"CAPTURED\") {\r\n    // Log replayed capture event for observability\r\n    logWebhookReplay({\r\n      provider: \"razorpay\",\r\n      event: \"payment.captured\",\r\n      paymentId: payment.id,\r\n      providerPaymentId: razorpayPaymentId,\r\n    });\r\n    // increment replay metric\r\n    try {\r\n      const { incReplay } = await import(\"../metrics/webhookMetrics\");\r\n      incReplay();\r\n    } catch {\r\n      // non-fatal\r\n    }\r\n    return;\r\n  }\r\n\r\n  await prisma.$transaction([\r\n    prisma.payment.update({\r\n      where: { id: payment.id },\r\n      data: {\r\n        providerPaymentId: razorpayPaymentId,\r\n        status: \"CAPTURED\",\r\n        rawPayload: event,\r\n      },\r\n    }),\r\n    prisma.booking.update({\r\n      where: { id: payment.bookingId },\r\n      data: {\r\n        paymentStatus: \"PAID\",\r\n        status: \"CONFIRMED\",\r\n      },\r\n    }),\r\n  ]);\r\n}\r\n\r\nexport async function handlePaymentFailed(event: any) {\r\n  const paymentEntity = event.payload?.payment?.entity;\r\n  const razorpayPaymentId = paymentEntity?.id;\r\n  const razorpayOrderId = paymentEntity?.order_id;\r\n\r\n  if (!razorpayOrderId) return;\r\n\r\n  const payment = await prisma.payment.findUnique({\r\n    where: { providerOrderId: razorpayOrderId },\r\n  });\r\n\r\n  if (!payment) return;\r\n\r\n  if (payment.status === \"FAILED\") {\r\n    // Log replayed failed event for observability\r\n    logWebhookReplay({\r\n      provider: \"razorpay\",\r\n      event: \"payment.failed\",\r\n      paymentId: payment.id,\r\n      providerPaymentId: razorpayPaymentId,\r\n    });\r\n    // increment replay metric\r\n    try {\r\n      const { incReplay } = await import(\"../metrics/webhookMetrics\");\r\n      incReplay();\r\n    } catch {\r\n      // non-fatal\r\n    }\r\n    return;\r\n  }\r\n\r\n  await prisma.$transaction([\r\n    prisma.payment.update({\r\n      where: { id: payment.id },\r\n      data: {\r\n        providerPaymentId: razorpayPaymentId,\r\n        status: \"FAILED\",\r\n        rawPayload: event,\r\n      },\r\n    }),\r\n    prisma.booking.update({\r\n      where: { id: payment.bookingId },\r\n      data: {\r\n        paymentStatus: \"FAILED\",\r\n      },\r\n    }),\r\n  ]);\r\n}\r\n\r\nexport async function handleRefundProcessed(event: any) {\r\n  const refundEntity = event.payload?.refund?.entity;\r\n  const razorpayPaymentId = refundEntity?.payment_id;\r\n\r\n  if (!razorpayPaymentId) return;\r\n\r\n  const payment = await prisma.payment.findUnique({\r\n    where: { providerPaymentId: razorpayPaymentId },\r\n  });\r\n\r\n  if (!payment) return;\r\n\r\n  await prisma.$transaction([\r\n    prisma.payment.update({\r\n      where: { id: payment.id },\r\n      data: {\r\n        status: \"REFUNDED\",\r\n        rawPayload: event,\r\n      },\r\n    }),\r\n    prisma.booking.update({\r\n      where: { id: payment.bookingId },\r\n      data: {\r\n        status: \"CANCELLED\",\r\n      },\r\n    }),\r\n  ]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\payments\\createManualPayment.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[423,426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[423,426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { logger } from \"../../lib/logger\";\r\nimport { notificationQueue } from \"../../lib/queue\";\r\n\r\nexport async function createManualPayment(req: Request, res: Response) {\r\n  const { bookingId, amount, method, transactionId, proofUrl } = req.body;\r\n  const adminId = (req.user as any).id;\r\n\r\n  if (!bookingId || !amount || !method) {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"Missing required fields\");\r\n  }\r\n\r\n  const booking = await prisma.booking.findUnique({\r\n    where: { id: bookingId },\r\n    include: { trip: true },\r\n  });\r\n\r\n  if (!booking) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Booking not found\");\r\n  }\r\n\r\n  // Verify Admin/Manager permissions (handled by middleware, but good to be safe)\r\n  // Assume route is protected by `requirePermission('trip:view:internal')` or similar\r\n\r\n  // Create Payment Record\r\n  const payment = await prisma.payment.create({\r\n    data: {\r\n      bookingId,\r\n      provider: method, // \"UPI\", \"CASH\", \"BANK_TRANSFER\"\r\n      providerOrderId: `MANUAL_${Date.now()}`, // Fake order ID\r\n      providerPaymentId: transactionId || `MANUAL_${Date.now()}`,\r\n      amount: Number(amount),\r\n      status: \"CAPTURED\",\r\n      proofUrl,\r\n      rawPayload: { adminId, recordedAt: new Date().toISOString(), method },\r\n    },\r\n  });\r\n\r\n  // Update Booking Status\r\n  await prisma.booking.update({\r\n    where: { id: bookingId },\r\n    data: {\r\n      status: \"CONFIRMED\",\r\n      paymentStatus: \"PAID\",\r\n    },\r\n  });\r\n\r\n  logger.info(\"Manual payment recorded\", { bookingId, adminId, amount });\r\n\r\n  // Send Notification\r\n  await notificationQueue.add(\"SEND_PAYMENT_EMAIL\", {\r\n    userId: booking.userId,\r\n    details: {\r\n      tripTitle: booking.trip.title,\r\n      amount: Number(amount),\r\n      bookingId,\r\n      method,\r\n    },\r\n  });\r\n\r\n  res.status(201).json(payment);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\payments\\createPaymentIntent.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[361,364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[361,364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1654,1657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1654,1657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2428,2431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2428,2431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { createRazorpayOrder } from \"../../services/razorpay.service\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { env } from \"../../config/env\";\r\n\r\nexport async function createPaymentIntent(req: Request, res: Response) {\r\n  const userId = (req.user as any).id; // Using non-null assertion as it's a protected route\r\n  const { bookingId } = req.body;\r\n\r\n  if (!bookingId) {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"bookingId is required\");\r\n  }\r\n\r\n  const booking = await prisma.booking.findUnique({\r\n    where: { id: bookingId },\r\n    include: { trip: true },\r\n  });\r\n\r\n  if (!booking) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Booking not found\");\r\n  }\r\n\r\n  if (booking.userId !== userId) {\r\n    throw new HttpError(403, \"FORBIDDEN\", \"Not your booking\");\r\n  }\r\n\r\n  // Support both CONFIRMED (if prepay is required after manual review)\r\n  // and REQUESTED (if payment is allowed immediately)\r\n  const allowedStatuses = [\"REQUESTED\", \"CONFIRMED\"];\r\n  if (!allowedStatuses.includes(booking.status)) {\r\n    throw new HttpError(\r\n      403,\r\n      \"INVALID_STATE\",\r\n      `Booking status must be one of [${allowedStatuses.join(\", \")}] to pay`,\r\n    );\r\n  }\r\n\r\n  // Amount in DB is in INR, Razorpay expects paise\r\n  const amount = booking.trip.price * 100;\r\n\r\n  if (!amount || amount <= 0) {\r\n    throw new HttpError(500, \"INVALID_AMOUNT\", \"Trip price misconfigured\");\r\n  }\r\n\r\n  const razorpayConfigured =\r\n    env.RAZORPAY_KEY_ID !== \"rzp_test_placeholder\" &&\r\n    env.RAZORPAY_KEY_SECRET !== \"placeholder_secret\";\r\n\r\n  let finalOrder: any = null;\r\n  try {\r\n    if (!razorpayConfigured) throw new Error(\"RazorpayNotConfigured\");\r\n\r\n    const order = await createRazorpayOrder({\r\n      amount,\r\n      currency: \"INR\",\r\n      receipt: booking.id,\r\n    });\r\n    finalOrder = order;\r\n  } catch {\r\n    if (!razorpayConfigured) {\r\n      if (env.NODE_ENV === \"production\") {\r\n        throw new HttpError(\r\n          500,\r\n          \"PAYMENT_PROVIDER_NOT_CONFIGURED\",\r\n          \"Payment service is temporarily unavailable\",\r\n        );\r\n      }\r\n\r\n      // DEV / TEST fallback\r\n      console.warn(\"[Payments] Using dev fallback Razorpay order\", { bookingId });\r\n      finalOrder = {\r\n        id: `order_test_${Date.now()}`,\r\n        amount: amount,\r\n        currency: \"INR\",\r\n        receipt: booking.id,\r\n      } as any;\r\n    } else {\r\n      throw new HttpError(500, \"INTERNAL_ERROR\", \"Failed to create provider order\");\r\n    }\r\n  }\r\n\r\n  const payment = await prisma.payment.create({\r\n    data: {\r\n      bookingId: booking.id,\r\n      provider: \"razorpay\",\r\n      providerOrderId: finalOrder.id,\r\n      amount,\r\n      status: \"CREATED\",\r\n    },\r\n  });\r\n\r\n  res.status(201).json({\r\n    paymentId: payment.id,\r\n    orderId: finalOrder.id,\r\n    amount,\r\n    currency: \"INR\",\r\n    key: env.RAZORPAY_KEY_ID,\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\payments\\refundBooking.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1573,1576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1573,1576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1943,1946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1943,1946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { razorpayService } from \"../../services/razorpay.service\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\n\r\nexport const refundBooking = async (req: Request, res: Response) => {\r\n  const { id } = req.params;\r\n\r\n  const booking = await prisma.booking.findUnique({\r\n    where: { id },\r\n    include: { payments: true },\r\n  });\r\n\r\n  if (!booking) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Booking not found\");\r\n  }\r\n\r\n  // Find a captured payment to refund (Assuming single payment for now)\r\n  const paymentToRefund = booking.payments.find(\r\n    (p) => p.status === \"CAPTURED\" || p.status === \"AUTHORIZED\",\r\n  );\r\n\r\n  if (!paymentToRefund || !paymentToRefund.providerPaymentId) {\r\n    throw new HttpError(400, \"BAD_REQUEST\", \"No refundable payment found for this booking\");\r\n  }\r\n\r\n  if (booking.status === \"CANCELLED\" && paymentToRefund.status === \"REFUNDED\") {\r\n    throw new HttpError(400, \"BAD_REQUEST\", \"Booking is already cancelled and refunded\");\r\n  }\r\n\r\n  try {\r\n    // 1. Process Refund with Razorpay\r\n    const refund = await razorpayService.refundPayment(paymentToRefund.providerPaymentId, {\r\n      bookingId: booking.id,\r\n      reason: \"Admin initiated refund\",\r\n    });\r\n\r\n    // 2. Update Database\r\n    // Update Payment record\r\n    await prisma.payment.update({\r\n      where: { id: paymentToRefund.id },\r\n      data: {\r\n        status: \"REFUNDED\",\r\n        razorpayRefundId: refund.id,\r\n      } as any,\r\n    });\r\n\r\n    // Update Booking Status to CANCELLED (since we refunded it)\r\n    const updatedBooking = await prisma.booking.update({\r\n      where: { id: booking.id },\r\n      data: { status: \"CANCELLED\" },\r\n    });\r\n\r\n    return ApiResponse.success(res, \"Refund processed successfully\", {\r\n      refund,\r\n      booking: updatedBooking,\r\n    });\r\n  } catch (error: any) {\r\n    console.error(\"Refund Controller Error:\", error);\r\n    throw new HttpError(\r\n      502,\r\n      \"GATEWAY_ERROR\",\r\n      error.error?.description || \"Refund processing failed\",\r\n    );\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\payments\\verifyPayment.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\razorpayWebhook.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1214,1217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1214,1217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { verifyRazorpaySignature } from \"../services/razorpay.service\";\r\nimport { handlePaymentCaptured, handlePaymentFailed, handleRefundProcessed } from \"./paymentEvents\";\r\nimport { HttpError } from \"../utils/httpError\";\r\nimport { env } from \"../config/env\";\r\nimport { incTotal, incFailed, incProcessed, setLatency } from \"../metrics/webhookMetrics\";\r\nimport { logger } from \"../lib/logger\";\r\n\r\nexport async function razorpayWebhookHandler(req: Request, res: Response) {\r\n  const signature = (req.headers[\"x-razorpay-signature\"] as string) || \"\";\r\n  const secret = env.RAZORPAY_WEBHOOK_SECRET;\r\n\r\n  if (!signature) {\r\n    throw new HttpError(400, \"INVALID_WEBHOOK\", \"Missing x-razorpay-signature header\");\r\n  }\r\n\r\n  // req.body is a Buffer because rawBodyMiddleware was applied\r\n  const payloadBuffer = req.body as Buffer;\r\n  const payloadString = payloadBuffer.toString(\"utf8\");\r\n\r\n  const valid = verifyRazorpaySignature(payloadString, signature, secret);\r\n\r\n  if (!valid) {\r\n    logger.warn(\"Razorpay webhook signature verification failed\", { signature });\r\n    throw new HttpError(400, \"INVALID_SIGNATURE\", \"Signature verification failed\");\r\n  }\r\n\r\n  let event: any;\r\n  try {\r\n    event = JSON.parse(payloadString);\r\n  } catch {\r\n    throw new HttpError(400, \"INVALID_PAYLOAD\", \"Invalid JSON payload\");\r\n  }\r\n\r\n  const start = Date.now();\r\n  incTotal();\r\n  logger.info(`Processing Razorpay webhook: ${event.event}`);\r\n\r\n  try {\r\n    switch (event.event) {\r\n      case \"payment.captured\":\r\n      case \"order.paid\":\r\n        await handlePaymentCaptured(event);\r\n        break;\r\n      case \"payment.failed\":\r\n        await handlePaymentFailed(event);\r\n        break;\r\n      case \"refund.processed\":\r\n        await handleRefundProcessed(event);\r\n        break;\r\n      default:\r\n        logger.info(`Ignoring Razorpay webhook event: ${event.event}`);\r\n        break;\r\n    }\r\n    incProcessed();\r\n  } catch (err) {\r\n    incFailed();\r\n    logger.error(\"Error handling Razorpay webhook\", { error: err, event: event.event });\r\n    throw err;\r\n  } finally {\r\n    setLatency(Date.now() - start);\r\n  }\r\n\r\n  return res.status(200).json({ received: true });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\review.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[271,274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[271,274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3727,3730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3727,3730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3772,3775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3772,3775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":182,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4670,4673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4670,4673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../lib/prisma\";\r\n\r\n// Create a review\r\nexport const createReview = async (req: Request, res: Response) => {\r\n  try {\r\n    const { tripId, rating, comment } = req.body;\r\n    const userId = (req.user as any).id; // AuthenticatedUser uses 'id' not 'userId'\r\n\r\n    // Validate inputs\r\n    if (!tripId || !rating) {\r\n      return res.status(400).json({ message: \"Trip ID and rating are required\" });\r\n    }\r\n\r\n    if (rating < 1 || rating > 5) {\r\n      return res.status(400).json({ message: \"Rating must be between 1 and 5\" });\r\n    }\r\n\r\n    // Check if user has a completed booking for this trip\r\n    const booking = await prisma.booking.findFirst({\r\n      where: {\r\n        userId,\r\n        tripId,\r\n        status: \"COMPLETED\",\r\n      },\r\n    });\r\n\r\n    if (!booking) {\r\n      return res.status(403).json({ message: \"You can only review trips you have completed.\" });\r\n    }\r\n\r\n    // Check if review already exists\r\n    const existingReview = await prisma.review.findUnique({\r\n      where: {\r\n        userId_tripId: {\r\n          userId,\r\n          tripId,\r\n        },\r\n      },\r\n    });\r\n\r\n    if (existingReview) {\r\n      return res.status(409).json({ message: \"You have already reviewed this trip.\" });\r\n    }\r\n\r\n    // Create review\r\n    const review = await prisma.review.create({\r\n      data: {\r\n        userId,\r\n        tripId,\r\n        rating,\r\n        comment,\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            avatarImage: {\r\n              select: {\r\n                thumbUrl: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    res.status(201).json(review);\r\n  } catch (error) {\r\n    console.error(\"Create Review Error:\", error);\r\n    res.status(500).json({ message: \"Failed to create review\" });\r\n  }\r\n};\r\n\r\n// Get reviews for a trip\r\nexport const getTripReviews = async (req: Request, res: Response) => {\r\n  try {\r\n    const { tripId } = req.params;\r\n\r\n    const reviews = await prisma.review.findMany({\r\n      where: {\r\n        tripId,\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            avatarImage: {\r\n              select: {\r\n                thumbUrl: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n    });\r\n\r\n    res.json(reviews);\r\n  } catch (error) {\r\n    console.error(\"Get Reviews Error:\", error);\r\n    res.status(500).json({ message: \"Failed to fetch reviews\" });\r\n  }\r\n};\r\n\r\n// Get featured reviews (Top rated, recent) for Home Page\r\nexport const getFeaturedReviews = async (req: Request, res: Response) => {\r\n  try {\r\n    const reviews = await prisma.review.findMany({\r\n      where: {\r\n        rating: {\r\n          gte: 4,\r\n        },\r\n      },\r\n      take: 3,\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            name: true,\r\n            avatarImage: {\r\n              select: {\r\n                thumbUrl: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        trip: {\r\n          select: {\r\n            title: true,\r\n            location: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    res.json(reviews);\r\n  } catch (error) {\r\n    console.error(\"Get Featured Reviews Error:\", error);\r\n    res.status(500).json({ message: \"Failed to fetch featured reviews\" });\r\n  }\r\n};\r\n\r\n// Delete a review (Admin or Owner)\r\nexport const deleteReview = async (req: Request, res: Response) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const userId = (req.user as any).id;\r\n    const userRoles = (req.user as any).roles;\r\n\r\n    const review = await prisma.review.findUnique({ where: { id } });\r\n\r\n    if (!review) {\r\n      return res.status(404).json({ message: \"Review not found\" });\r\n    }\r\n\r\n    // Allow deletion if admin or if own review\r\n    if (review.userId !== userId && !userRoles.includes(\"ADMIN\")) {\r\n      return res.status(403).json({ message: \"Not authorized to delete this review\" });\r\n    }\r\n\r\n    await prisma.review.delete({ where: { id } });\r\n\r\n    // ... (existing deleteReview)\r\n    res.json({ message: \"Review deleted successfully\" });\r\n  } catch (error) {\r\n    console.error(\"Delete Review Error:\", error);\r\n    res.status(500).json({ message: \"Failed to delete review\" });\r\n  }\r\n};\r\n\r\n// Check if user is eligible to review\r\nexport const checkReviewEligibility = async (req: Request, res: Response) => {\r\n  try {\r\n    const { tripId } = req.params;\r\n    const userId = (req.user as any).id;\r\n\r\n    // 1. Check for Completed Booking\r\n    const booking = await prisma.booking.findFirst({\r\n      where: {\r\n        userId,\r\n        tripId,\r\n        status: \"COMPLETED\",\r\n      },\r\n    });\r\n\r\n    if (!booking) {\r\n      return res.json({ eligible: false, reason: \"You typically need to complete a trip to review it.\" });\r\n    }\r\n\r\n    // 2. Check for Existing Review\r\n    const existingReview = await prisma.review.findUnique({\r\n      where: {\r\n        userId_tripId: {\r\n          userId,\r\n          tripId,\r\n        },\r\n      },\r\n    });\r\n\r\n    if (existingReview) {\r\n      return res.json({ eligible: false, reason: \"You have already reviewed this trip.\" });\r\n    }\r\n\r\n    res.json({ eligible: true });\r\n  } catch (error) {\r\n    console.error(\"Check Eligibility Error:\", error);\r\n    res.status(500).json({ message: \"Failed to check eligibility\" });\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\reviews\\checkReviewEligibility.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[296,299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[296,299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\n\r\nexport const checkReviewEligibility = catchAsync(async (req: Request, res: Response) => {\r\n  const { tripId } = req.params;\r\n  const userId = (req as any).user.id;\r\n\r\n  // Check if user has a completed booking for this trip\r\n  // For now, allowing any booking or even just being a user if we want easier testing\r\n  // But strict logic:\r\n  /*\r\n  const booking = await prisma.booking.findFirst({\r\n    where: {\r\n      userId,\r\n      tripId,\r\n      status: \"COMPLETED\",\r\n    },\r\n  });\r\n  */\r\n\r\n  // For stabilization/testing phase, we relax this or check just Booking existence\r\n  const booking = await prisma.booking.findFirst({\r\n    where: {\r\n      userId,\r\n      tripId,\r\n    },\r\n  });\r\n\r\n  const hasReview = await prisma.review.findUnique({\r\n    where: {\r\n      userId_tripId: { userId, tripId },\r\n    },\r\n  });\r\n\r\n  if (hasReview) {\r\n    return res.json({ eligible: false, reason: \"You have already reviewed this trip.\" });\r\n  }\r\n\r\n  if (!booking) {\r\n    return res.json({ eligible: false, reason: \"You need a booking for this trip.\" });\r\n  }\r\n\r\n  return res.json({ eligible: true });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\reviews\\createReview.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[409,412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[409,412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const createReview = catchAsync(async (req: Request, res: Response) => {\r\n  const { tripId, rating, comment } = req.body;\r\n  const userId = (req as any).user.id;\r\n\r\n  if (!tripId || !rating) {\r\n    throw new HttpError(400, \"BAD_REQUEST\", \"Trip ID and Rating are required\");\r\n  }\r\n\r\n  // Check if user already reviewed\r\n  const existingReview = await prisma.review.findUnique({\r\n    where: {\r\n      userId_tripId: {\r\n        userId,\r\n        tripId,\r\n      },\r\n    },\r\n  });\r\n\r\n  if (existingReview) {\r\n    throw new HttpError(409, \"CONFLICT\", \"You have already reviewed this trip\");\r\n  }\r\n\r\n  // Create review\r\n  const review = await prisma.review.create({\r\n    data: {\r\n      userId,\r\n      tripId,\r\n      rating,\r\n      comment,\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Review created successfully\", review, 201);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\reviews\\getTripReviews.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\siteConfig.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\approveTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[305,308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[305,308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const approveTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n  if (trip.status !== \"PENDING_REVIEW\")\r\n    return ApiResponse.error(res, \"Invalid state transition\", 403);\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: {\r\n      status: \"APPROVED\",\r\n      approvedById: user.id,\r\n    },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_APPROVED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip approved successfully\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\archiveTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[305,308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[305,308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const archiveTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n  if (trip.status !== \"PUBLISHED\") return ApiResponse.error(res, \"Invalid state transition\", 403);\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: { status: \"ARCHIVED\" },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_ARCHIVED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip archived successfully\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\completeTrip.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\createTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[304,307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[304,307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1700,1703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1700,1703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const createTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n\r\n  const trip = await prisma.trip.create({\r\n    data: {\r\n      title: req.body.title,\r\n      slug: req.body.slug,\r\n      description: req.body.description,\r\n      itinerary: req.body.itinerary,\r\n      durationDays: req.body.durationDays,\r\n      difficulty: req.body.difficulty,\r\n      location: req.body.location,\r\n      price: req.body.price,\r\n      // Expanded fields\r\n      category: req.body.category,\r\n      capacity: req.body.capacity || 0,\r\n      startPoint: req.body.startPoint,\r\n      endPoint: req.body.endPoint,\r\n      altitude: req.body.altitude,\r\n      distance: req.body.distance,\r\n      itineraryPdf: req.body.itineraryPdf,\r\n      highlights: req.body.highlights,\r\n      inclusions: req.body.inclusions,\r\n      exclusions: req.body.exclusions,\r\n      cancellationPolicy: req.body.cancellationPolicy,\r\n      thingsToPack: req.body.thingsToPack,\r\n      faqs: req.body.faqs,\r\n      seasons: req.body.seasons,\r\n      isFeatured: req.body.isFeatured || false,\r\n      startDate: req.body.startDate ? new Date(req.body.startDate) : null,\r\n      endDate: req.body.endDate ? new Date(req.body.endDate) : null,\r\n      coverImageId: req.body.coverImageId || null,\r\n      heroImageId: req.body.heroImageId || null,\r\n      createdById: user.id,\r\n      gallery:\r\n        req.body.gallery && req.body.gallery.length > 0\r\n          ? {\r\n              create: req.body.gallery.map((g: any, index: number) => ({\r\n                imageId: g.id,\r\n                order: index,\r\n              })),\r\n            }\r\n          : undefined,\r\n    },\r\n    include: {\r\n      coverImage: true,\r\n      gallery: {\r\n        include: { image: true },\r\n        orderBy: { order: \"asc\" },\r\n      },\r\n    },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_CREATED\",\r\n      targetType: \"TRIP\",\r\n      targetId: trip.id,\r\n      metadata: { status: trip.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip created successfully\", trip, 201);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\deleteTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1643,1646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1643,1646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const deleteTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({\r\n    where: { id },\r\n    include: { bookings: true }\r\n  });\r\n\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  // Constraint 1: Cannot delete PUBLISHED trips\r\n  if (trip.status === \"PUBLISHED\") {\r\n    throw new HttpError(400, \"BAD_REQUEST\", \"Cannot delete a PUBLISHED trip. Please Archive it instead.\");\r\n  }\r\n\r\n  // Constraint 2: Cannot delete trip while running (IN_PROGRESS)\r\n  if (trip.status === \"IN_PROGRESS\") {\r\n    throw new HttpError(400, \"BAD_REQUEST\", \"Cannot delete an IN_PROGRESS trip.\");\r\n  }\r\n  \r\n  // Constraint 3 (Implicit): Safety check for bookings?\r\n  // User said \"while trip is running\", implying future bookings might be okay to cancel?\r\n  // But usually hard deleting a trip with bookings breaks referential integrity or history.\r\n  // We'll trust the User's specific constraints for now.\r\n  // But if there are bookings, Prisma might throw Foreign Key error unless Cascade Delete is on.\r\n  // Schema check: SavedTrip (Cascade), Review (No Cascade?), Booking (No Cascade?).\r\n  // If Booking exists, delete usually fails.\r\n  // We should warn user or block it. \r\n  \r\n  const hasActiveBookings = trip.bookings.some(b => \r\n    [\"CONFIRMED\", \"PAID\"].includes(b.status as any) || b.paymentStatus === \"PAID\"\r\n  );\r\n\r\n  if (hasActiveBookings) {\r\n      // If user insists on deleting, they must cancel bookings first.\r\n      throw new HttpError(400, \"BAD_REQUEST\", \"Trip has active bookings. Cancel them before deleting.\");\r\n  }\r\n\r\n\r\n  await prisma.trip.delete({\r\n    where: { id },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip deleted successfully\", null);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\getManagerTrips.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[480,483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[480,483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const getManagerTrips = catchAsync(async (req: Request, res: Response) => {\r\n  const userId = req.user?.id;\r\n  if (!userId) {\r\n    return ApiResponse.error(res, \"Unauthenticated\", 401);\r\n  }\r\n\r\n  // Optional status filter\r\n  const { status } = req.query;\r\n  const where: any = {\r\n    managerId: userId,\r\n  };\r\n\r\n  if (status) {\r\n    where.status = status;\r\n  }\r\n\r\n  const trips = await prisma.trip.findMany({\r\n    where,\r\n    orderBy: { startDate: \"asc\" },\r\n    include: {\r\n      coverImage: true,\r\n      guides: {\r\n        include: {\r\n          guide: { select: { id: true, name: true, email: true, avatarImage: true } },\r\n        },\r\n      },\r\n      _count: {\r\n        select: { bookings: true },\r\n      },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Manager trips fetched\", trips);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\getPublicTrips.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[533,536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[533,536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const getPublicTrips = catchAsync(async (req: Request, res: Response) => {\r\n\r\n  const {\r\n    search,\r\n    category,\r\n    difficulty,\r\n    maxPrice,\r\n    minPrice,\r\n    minDays,\r\n    maxDays,\r\n    startDate,\r\n    endDate,\r\n    capacity,\r\n    sortBy = \"createdAt\",\r\n    sortOrder = \"desc\",\r\n  } = req.query;\r\n\r\n  const where: any = { status: \"PUBLISHED\" };\r\n\r\n  if (search) {\r\n    // Upgraded to Prisma's full-text search capability\r\n    where.OR = [\r\n      { title: { search: String(search).split(\" \").join(\" & \") } },\r\n      { description: { search: String(search).split(\" \").join(\" & \") } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    where.category = category;\r\n  }\r\n\r\n  if (difficulty) {\r\n    where.difficulty = difficulty;\r\n  }\r\n\r\n  if (capacity) {\r\n    where.capacity = { gte: Number(capacity) };\r\n  }\r\n\r\n  if (maxPrice || minPrice) {\r\n    where.price = {};\r\n    if (maxPrice) where.price.lte = Number(maxPrice);\r\n    if (minPrice) where.price.gte = Number(minPrice);\r\n  }\r\n\r\n  if (minDays || maxDays) {\r\n    where.durationDays = {};\r\n    if (minDays) where.durationDays.gte = Number(minDays);\r\n    if (maxDays) where.durationDays.lte = Number(maxDays);\r\n  }\r\n\r\n  if (startDate || endDate) {\r\n    where.startDate = {};\r\n    if (startDate) where.startDate.gte = new Date(String(startDate));\r\n    if (endDate) where.startDate.lte = new Date(String(endDate));\r\n  }\r\n\r\n  if (Boolean(req.query.isFeatured) === true) {\r\n    where.isFeatured = true;\r\n  }\r\n\r\n  // Define allowed sort fields to prevent injection\r\n  const allowedSortFields = [\"price\", \"durationDays\", \"startDate\", \"createdAt\", \"title\"];\r\n  const finalSortField = allowedSortFields.includes(String(sortBy)) ? String(sortBy) : \"createdAt\";\r\n  const finalSortOrder = sortOrder === \"asc\" ? \"asc\" : \"desc\";\r\n\r\n  const trips = await prisma.trip.findMany({\r\n    where,\r\n    orderBy: { [finalSortField]: finalSortOrder },\r\n    include: {\r\n      coverImage: true,\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trips fetched\", trips);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\getTripBySlug.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[929,932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[929,932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1555,1558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1555,1558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1607,1610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1607,1610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const getTripBySlug = catchAsync(async (req: Request, res: Response) => {\r\n  const { slug } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({\r\n    where: { slug },\r\n    include: {\r\n      coverImage: true,\r\n      heroImage: true,\r\n      gallery: {\r\n        include: {\r\n          image: true,\r\n        },\r\n        orderBy: {\r\n          order: \"asc\",\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  if (trip.status === \"PUBLISHED\") {\r\n    return ApiResponse.success(res, \"Trip Fetched\", trip);\r\n  }\r\n\r\n  // If not published, check for internal permission\r\n  const user = (req as any).user;\r\n  if (user) {\r\n    // We need to fetch permissions effectively since optionalAuth doesn't hydration them\r\n    const dbUser = await prisma.user.findUnique({\r\n      where: { id: user.id },\r\n      include: {\r\n        roles: {\r\n          include: {\r\n            role: {\r\n              include: {\r\n                permissions: {\r\n                  include: {\r\n                    permission: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (dbUser) {\r\n      const permissions = new Set<string>();\r\n      dbUser.roles.forEach((ur: any) => {\r\n        ur.role.permissions.forEach((rp: any) => {\r\n          permissions.add(rp.permission.key);\r\n        });\r\n      });\r\n\r\n      if (permissions.has(\"trip:view:internal\") || trip.createdById === user.id) {\r\n        return ApiResponse.success(res, \"Trip Fetched (Internal)\", trip);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback to hiding existence\r\n  throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\internalTrips.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[525,528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[525,528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[609,612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[609,612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const getInternalTrips = catchAsync(async (req: Request, res: Response) => {\r\n  const { status, page = 1, limit = 10, sortBy = \"createdAt\", sortOrder = \"desc\" } = req.query;\r\n\r\n  const pageNumber = Number(page);\r\n  const limitNumber = Number(limit);\r\n  const skip = (pageNumber - 1) * limitNumber;\r\n\r\n  const where: any = {};\r\n  if (status) {\r\n    where.status = status;\r\n  }\r\n\r\n  const sortOptions: any = {};\r\n  if (sortBy && sortOrder) {\r\n    sortOptions[String(sortBy)] = sortOrder;\r\n  }\r\n\r\n  const [trips, total] = await Promise.all([\r\n    prisma.trip.findMany({\r\n      where,\r\n      orderBy: sortOptions,\r\n      skip,\r\n      take: limitNumber,\r\n      include: {\r\n        coverImage: true,\r\n      },\r\n    }),\r\n    prisma.trip.count({ where }),\r\n  ]);\r\n\r\n  const totalPages = Math.ceil(total / limitNumber);\r\n\r\n  return ApiResponse.success(res, \"Internal trips fetched\", {\r\n    data: trips,\r\n    metadata: {\r\n      total,\r\n      page: pageNumber,\r\n      limit: limitNumber,\r\n      totalPages,\r\n    },\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\publishTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[305,308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[305,308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const publishTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n  if (trip.status !== \"APPROVED\") return ApiResponse.error(res, \"Invalid state transition\", 403);\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: {\r\n      status: \"PUBLISHED\",\r\n      publishedAt: new Date(),\r\n    },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_PUBLISHED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip published successfully\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\restoreTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[305,308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[305,308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const restoreTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n  if (trip.status !== \"ARCHIVED\") return ApiResponse.error(res, \"Only archived trips can be restored\", 400);\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: { status: \"DRAFT\" },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_RESTORED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip restored to Draft\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\submitTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[304,307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[304,307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const submitTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n  if (trip.createdById !== user.id) return ApiResponse.error(res, \"Not owner\", 403);\r\n  if (trip.status !== \"DRAFT\") return ApiResponse.error(res, \"Invalid state transition\", 403);\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: { status: \"PENDING_REVIEW\" },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_SUBMITTED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip submitted successfully\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\updateTrip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[304,307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[304,307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2326,2329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2326,2329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const updateTrip = catchAsync(async (req: Request, res: Response) => {\r\n  const user = (req as any).user;\r\n  const { id } = req.params;\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n\r\n  if (!trip) return ApiResponse.error(res, \"Trip not found\", 404);\r\n\r\n  // Check permissions: Owner OR Admin (trip:edit)\r\n  const isOwner = trip.createdById === user.id;\r\n  const canEditAny = user.permissions?.includes(\"trip:edit\");\r\n\r\n  if (!isOwner && !canEditAny) {\r\n    return ApiResponse.error(res, \"Insufficient permissions to edit this trip\", 403);\r\n  }\r\n\r\n  // Allow editing even if not DRAFT if user is Admin\r\n  if (trip.status !== \"DRAFT\" && !canEditAny) {\r\n    return ApiResponse.error(res, \"Only drafts can be edited by owners\", 403);\r\n  }\r\n\r\n  const updated = await prisma.trip.update({\r\n    where: { id },\r\n    data: {\r\n      title: req.body.title,\r\n      slug: req.body.slug,\r\n      description: req.body.description,\r\n      itinerary: req.body.itinerary,\r\n      location: req.body.location,\r\n      price: req.body.price,\r\n      // Expanded fields\r\n      category: req.body.category,\r\n      capacity: req.body.capacity,\r\n      startPoint: req.body.startPoint,\r\n      endPoint: req.body.endPoint,\r\n      altitude: req.body.altitude,\r\n      distance: req.body.distance,\r\n      itineraryPdf: req.body.itineraryPdf,\r\n      highlights: req.body.highlights,\r\n      inclusions: req.body.inclusions,\r\n      exclusions: req.body.exclusions,\r\n      cancellationPolicy: req.body.cancellationPolicy,\r\n      thingsToPack: req.body.thingsToPack,\r\n      faqs: req.body.faqs,\r\n      seasons: req.body.seasons,\r\n      durationDays: req.body.durationDays,\r\n      difficulty: req.body.difficulty,\r\n      isFeatured: req.body.isFeatured,\r\n      startDate: req.body.startDate ? new Date(req.body.startDate) : null,\r\n      endDate: req.body.endDate ? new Date(req.body.endDate) : null,\r\n      coverImageId: req.body.coverImageId,\r\n      heroImageId: req.body.heroImageId,\r\n      // Update gallery\r\n      gallery: req.body.gallery\r\n        ? {\r\n            deleteMany: {},\r\n            create: req.body.gallery.map((g: any, index: number) => ({\r\n              imageId: g.id,\r\n              order: index,\r\n            })),\r\n          }\r\n        : undefined,\r\n    },\r\n    include: {\r\n      coverImage: true,\r\n      gallery: {\r\n        include: { image: true },\r\n        orderBy: { order: \"asc\" },\r\n      },\r\n    },\r\n  });\r\n\r\n  await prisma.auditLog.create({\r\n    data: {\r\n      actorId: user.id,\r\n      action: \"TRIP_UPDATED\",\r\n      targetType: \"TRIP\",\r\n      targetId: updated.id,\r\n      metadata: { status: updated.status },\r\n    },\r\n  });\r\n\r\n  return ApiResponse.success(res, \"Trip updated successfully\", updated);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\trips\\uploadTripDocs.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1414,1417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1414,1417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1517,1520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1517,1520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1616,1619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1616,1619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2260,2263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2260,2263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { prisma } from \"../../lib/prisma\";\r\nimport { HttpError } from \"../../utils/httpError\";\r\nimport { logger } from \"../../lib/logger\";\r\nimport { catchAsync } from \"../../utils/catchAsync\";\r\nimport { ApiResponse } from \"../../utils/ApiResponse\";\r\n\r\nexport const uploadTripDocs = catchAsync(async (req: Request, res: Response) => {\r\n  const { id } = req.params;\r\n  const userId = req.user!.id;\r\n\r\n  // Expecting body: { type: \"GROUP_PHOTO\" | \"REPORT\" | \"OTHER\", url: string, description?: string }\r\n  const { type, url, description } = req.body;\r\n\r\n  if (!url || !type) {\r\n    throw new HttpError(400, \"INVALID_REQUEST\", \"URL and Type are required\");\r\n  }\r\n\r\n  const trip = await prisma.trip.findUnique({ where: { id } });\r\n  if (!trip) {\r\n    throw new HttpError(404, \"NOT_FOUND\", \"Trip not found\");\r\n  }\r\n\r\n  // Authz: Guide assigned to trip OR Manager/Admin\r\n  const isAssignedGuide = await prisma.tripsOnGuides.findUnique({\r\n    where: { tripId_guideId: { tripId: id, guideId: userId } },\r\n  });\r\n\r\n  const isManager = trip.managerId === userId;\r\n  const isAdmin = req.user?.roles.includes(\"ADMIN\") || req.user?.roles.includes(\"SUPER_ADMIN\");\r\n\r\n  if (!isAssignedGuide && !isManager && !isAdmin) {\r\n    throw new HttpError(403, \"FORBIDDEN\", \"You are not authorized to upload docs for this trip\");\r\n  }\r\n\r\n  // Append to existing docs safely\r\n  let existingDocs: any[] = [];\r\n  // explicit cast due to outdated prisma client (locked file)\r\n  const tripAny = trip as any;\r\n\r\n  if (Array.isArray(tripAny.documentation)) {\r\n    existingDocs = tripAny.documentation as any[];\r\n  } else if (tripAny.documentation) {\r\n    // If it exists but isn't an array (unexpected), wrap it or ignore?\r\n    console.warn(\r\n      `[UploadDocs] Warning: trip.documentation is not an array:`,\r\n      tripAny.documentation,\r\n    );\r\n    // existingDocs = [trip.documentation]; // Optional recovery\r\n  }\r\n\r\n  const newDoc = {\r\n    id: Date.now().toString(), // Simple ID\r\n    type,\r\n    url,\r\n    description,\r\n    uploadedBy: userId,\r\n    uploadedAt: new Date().toISOString(),\r\n  };\r\n\r\n  const updatedDocs = [...existingDocs, newDoc];\r\n\r\n  await prisma.trip.update({\r\n    where: { id },\r\n    data: { documentation: updatedDocs } as any, // Cast for stale client\r\n  });\r\n\r\n  logger.info(\"Trip Doc Uploaded\", { tripId: id, userId, type });\r\n\r\n  return ApiResponse.success(res, \"Document uploaded\", { documentation: updatedDocs });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\user.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[316,319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[316,319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { userService } from \"../services/user.service\";\r\nimport { catchAsync } from \"../utils/catchAsync\";\r\nimport { ApiResponse } from \"../utils/ApiResponse\";\r\n\r\nexport const updateProfile = catchAsync(async (req: Request, res: Response) => {\r\n  const userId = (req as any).user.id;\r\n\r\n  const user = await userService.updateProfile(userId, req.body);\r\n\r\n  return ApiResponse.success(res, \"Profile updated successfully\", {\r\n    user,\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\controllers\\wishlist.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\domain\\booking\\bookingTransitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\instrument.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\__mocks__\\prisma.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\prisma.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\queue.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[413,416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[413,416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Queue, Worker, Job } from \"bullmq\";\r\nimport { redisConnection } from \"./redis\";\r\nimport { prisma } from \"./prisma\";\r\nimport { notificationService } from \"../services/notification.service\";\r\nimport { emitToUser } from \"./socket\";\r\n\r\n// Define Job Data Types\r\nexport type JobType = \"SEND_BOOKING_EMAIL\" | \"SEND_PAYMENT_EMAIL\" | \"SEND_ASSIGNMENT_EMAIL\";\r\n\r\ninterface JobData {\r\n  type: JobType;\r\n  payload: any;\r\n}\r\n\r\nconst QUEUE_NAME = \"param_adventures_notifications\";\r\n\r\n// 1. Create the Queue\r\nexport const notificationQueue = new Queue(QUEUE_NAME, {\r\n  connection: redisConnection,\r\n  defaultJobOptions: {\r\n    attempts: 3,\r\n    backoff: {\r\n      type: \"exponential\",\r\n      delay: 5000, // Wait 5s, then 10s, then 20s\r\n    },\r\n    removeOnComplete: true,\r\n  },\r\n});\r\n\r\n// 2. Create the Worker\r\nexport const notificationWorker = new Worker(\r\n  QUEUE_NAME,\r\n  async (job: Job<JobData>) => {\r\n    const { type, payload } = job.data;\r\n    console.log(`👷 Processing job ${job.id} of type ${type}...`);\r\n\r\n    try {\r\n      // Common: Fetch user details if userId is provided\r\n      let user = null;\r\n      if (payload.userId) {\r\n        user = await prisma.user.findUnique({ where: { id: payload.userId } });\r\n      }\r\n\r\n      if (!user && payload.userId) {\r\n        console.warn(`⚠️ User not found for job ${job.id}`);\r\n        return;\r\n      }\r\n\r\n      switch (type) {\r\n        case \"SEND_BOOKING_EMAIL\":\r\n          await notificationService.sendBookingConfirmation(user!.email, {\r\n            ...payload.details,\r\n            userName: user!.name || user!.email,\r\n          });\r\n          emitToUser(payload.userId, \"booking_update\", {\r\n            message: \"Booking request received\",\r\n            details: payload.details,\r\n          });\r\n          break;\r\n        case \"SEND_PAYMENT_EMAIL\":\r\n          await notificationService.sendPaymentSuccess(user!.email, {\r\n            ...payload.details,\r\n            userName: user!.name || user!.email,\r\n          });\r\n          emitToUser(payload.userId, \"payment_update\", {\r\n            status: \"SUCCESS\",\r\n            message: \"Payment verified successfully!\",\r\n          });\r\n          break;\r\n        case \"SEND_ASSIGNMENT_EMAIL\":\r\n          await notificationService.sendAssignmentNotification(user!.email, {\r\n            ...payload.details,\r\n            role: payload.role,\r\n            userName: user!.name || user!.email,\r\n          });\r\n          emitToUser(payload.userId, \"assignment_update\", {\r\n            role: payload.role,\r\n            tripTitle: payload.details.tripTitle,\r\n          });\r\n          break;\r\n        default:\r\n          console.warn(`❓ Unknown job type: ${type}`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`❌ Error processing job ${job.id}:`, error);\r\n      throw error; // Rethrow to trigger BullMQ retry\r\n    }\r\n  },\r\n  { connection: redisConnection },\r\n);\r\n\r\nnotificationWorker.on(\"completed\", (job) => {\r\n  console.log(`✅ Job ${job.id} completed successfully`);\r\n});\r\n\r\nnotificationWorker.on(\"failed\", (job, err) => {\r\n  console.error(`❌ Job ${job?.id} failed:`, err);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\lib\\socket.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[289,292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[289,292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1385,1388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1385,1388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1589,1592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1589,1592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2120,2123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2120,2123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Server } from \"socket.io\";\r\nimport { createAdapter } from \"@socket.io/redis-adapter\";\r\nimport { createRedisClient } from \"./redis\";\r\nimport { verifyAccessToken } from \"../utils/jwt\";\r\nimport { logger } from \"./logger\";\r\n\r\nlet io: Server;\r\n\r\nexport function initSocket(httpServer: any) {\r\n  const pubClient = createRedisClient();\r\n  const subClient = createRedisClient();\r\n\r\n  io = new Server(httpServer, {\r\n    cors: {\r\n      origin: [\r\n        \"http://localhost:3000\",\r\n        \"http://localhost:3001\",\r\n        \"https://param-adventures-phase1-web.vercel.app\",\r\n        \"https://param-adventures-phase1-web-git-main-akashs-projects.vercel.app\", // Adjust if needed\r\n        process.env.FRONTEND_URL || \"\", // Allow env var override\r\n      ].filter(Boolean),\r\n      methods: [\"GET\", \"POST\"],\r\n      credentials: true, // Required for cookies/headers if client sends them\r\n    },\r\n  });\r\n\r\n  io.adapter(createAdapter(pubClient, subClient));\r\n\r\n  // Authentication Middleware for Sockets\r\n  io.use((socket, next) => {\r\n    const token = socket.handshake.auth.token || socket.handshake.headers.authorization;\r\n\r\n    if (!token) {\r\n      return next(new Error(\"Authentication error: No token provided\"));\r\n    }\r\n\r\n    try {\r\n      const actualToken = token.startsWith(\"Bearer \") ? token.slice(7) : token;\r\n      const payload = verifyAccessToken(actualToken);\r\n      (socket as any).userId = payload.sub;\r\n      next();\r\n    } catch {\r\n      next(new Error(\"Authentication error: Invalid token\"));\r\n    }\r\n  });\r\n\r\n  io.on(\"connection\", (socket) => {\r\n    const userId = (socket as any).userId;\r\n    logger.info(`🔌 Socket connected: ${socket.id} (User: ${userId})`);\r\n\r\n    // Join a private room for this user\r\n    socket.join(`user:${userId}`);\r\n\r\n    socket.on(\"disconnect\", () => {\r\n      logger.info(`🔌 Socket disconnected: ${socket.id}`);\r\n    });\r\n  });\r\n\r\n  return io;\r\n}\r\n\r\nexport function getIO() {\r\n  if (!io) {\r\n    throw new Error(\"Socket.io not initialized!\");\r\n  }\r\n  return io;\r\n}\r\n\r\n/**\r\n * Emit an event to a specific user\r\n */\r\nexport function emitToUser(userId: string, event: string, data: any) {\r\n  if (!io) return;\r\n  io.to(`user:${userId}`).emit(event, data);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\metrics\\webhookMetrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\audit.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[925,928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[925,928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from \"express\";\r\nimport { auditService } from \"../services/audit.service\";\r\n\r\ninterface AutoLogOptions {\r\n  action: string;\r\n  targetType: string;\r\n  /**\r\n   * Function to extract target ID from request.\r\n   * Defaults to req.params.id if not provided.\r\n   */\r\n  getTargetId?: (req: Request) => string | undefined;\r\n}\r\n\r\nexport function autoLog(options: AutoLogOptions) {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    // We hook into the response 'finish' event to log after the action is done.\r\n    // This allows us to know the status code (success/fail).\r\n    res.on(\"finish\", () => {\r\n      // Only log successful mutations or specific errors if needed.\r\n      // Usually, audit logs track what *happened*.\r\n      // If the status is 2xx, the action succeeded.\r\n      if (res.statusCode >= 200 && res.statusCode < 300) {\r\n        const actorId = (req as any).user?.id;\r\n        const targetId = options.getTargetId ? options.getTargetId(req) : req.params.id;\r\n\r\n        auditService.logAudit({\r\n          actorId,\r\n          action: options.action,\r\n          targetType: options.targetType,\r\n          targetId,\r\n          metadata: {\r\n            method: req.method,\r\n            url: req.originalUrl,\r\n            ip: req.ip,\r\n            userAgent: req.headers[\"user-agent\"],\r\n          },\r\n        });\r\n      }\r\n    });\r\n\r\n    next();\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\auth.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\error.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\permission.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1079,1082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1079,1082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from \"express\";\r\nimport { prisma } from \"../lib/prisma\";\r\n\r\nexport async function attachPermissions(req: Request, res: Response, next: NextFunction) {\r\n  try {\r\n    const userId = req.user?.id;\r\n    if (!userId) {\r\n      return res.status(401).json({ error: \"Unauthenticated\" });\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n      include: {\r\n        roles: {\r\n          include: {\r\n            role: {\r\n              include: {\r\n                permissions: {\r\n                  include: { permission: true },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      return res.status(401).json({ error: \"User not found\" });\r\n    }\r\n\r\n    if (user.status !== \"ACTIVE\") {\r\n      return res.status(403).json({\r\n        error: `Your account status is ${user.status}.`,\r\n        status: user.status,\r\n        reason: user.statusReason,\r\n      });\r\n    }\r\n\r\n    const roles = user.roles;\r\n\r\n    const roleNames = roles.map((r: any) => r.role?.name).filter(Boolean) as string[];\r\n\r\n    const permissionsSet = new Set<string>();\r\n    for (const r of roles) {\r\n      const perms = r.role?.permissions ?? [];\r\n      for (const p of perms) {\r\n        const key = p?.permission?.key;\r\n        if (key) permissionsSet.add(key);\r\n      }\r\n    }\r\n\r\n    if (req.user) {\r\n      req.user.roles = roleNames;\r\n      req.user.permissions = Array.from(permissionsSet);\r\n      req.permissions = req.user.permissions; // Also attach to req.permissions as seen in trips.routes\r\n    }\r\n\r\n    return next();\r\n  } catch (err) {\r\n    return next(err);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\rawBody.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\require-permission.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[305,308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[305,308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1344,1347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1344,1347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from \"express\";\r\nimport { HttpError } from \"../utils/httpError\";\r\nimport { prisma } from \"../lib/prisma\";\r\n\r\nexport function requirePermission(permission: string) {\r\n  return async (req: Request, res: Response, next: NextFunction) => {\r\n    const user = (req as any).user;\r\n\r\n    if (!user) {\r\n      throw new HttpError(403, \"FORBIDDEN\", \"Unauthenticated\");\r\n    }\r\n\r\n    // Check if permission is present in current list\r\n    if (user.permissions && user.permissions.includes(permission)) {\r\n      return next();\r\n    }\r\n\r\n    // If not present (or permissions list is empty), fetch from DB to be sure\r\n    const dbUser = await prisma.user.findUnique({\r\n      where: { id: user.id },\r\n      include: {\r\n        roles: {\r\n          include: {\r\n            role: {\r\n              include: {\r\n                permissions: {\r\n                  include: {\r\n                    permission: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (dbUser) {\r\n      const permissions = new Set<string>();\r\n      dbUser.roles.forEach((ur) => {\r\n        ur.role.permissions.forEach((rp) => {\r\n          permissions.add(rp.permission.key);\r\n        });\r\n      });\r\n      user.permissions = Array.from(permissions);\r\n      (req as any).user.permissions = user.permissions; // persist for downstream\r\n    }\r\n\r\n    // Final check\r\n    if (!user.permissions?.includes(permission)) {\r\n      throw new HttpError(\r\n        403,\r\n        \"FORBIDDEN\",\r\n        `You do not have permission to perform this action (${permission})`,\r\n      );\r\n    }\r\n\r\n    next();\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\require-role.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[197,200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[197,200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from \"express\";\r\n\r\nexport function requireRole(role: string) {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    const user = (req as any).user;\r\n\r\n    if (!user?.roles?.includes(role)) {\r\n      return res.status(403).json({ error: \"Forbidden\" });\r\n    }\r\n\r\n    next();\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\upload.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\middlewares\\validate.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\audit.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\bookings.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\dashboard.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\inquiry.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\roles.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\trip-assignment.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\trip-bookings.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\admin\\users.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\blogs.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\bookings.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\content.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\inquiry.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\media.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\metrics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\newsletter.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\payments.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\review.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\reviews.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\trips.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\user.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\webhooks.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\routes\\wishlist.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\schemas\\auth.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\__mocks__\\razorpay.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[163,166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[163,166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\audit.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[197,200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[197,200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from \"../lib/prisma\";\r\n\r\nexport interface AuditLogData {\r\n  action: string;\r\n  actorId?: string;\r\n  actorName?: string;\r\n  targetType: string;\r\n  targetId?: string;\r\n  metadata?: any;\r\n}\r\n\r\nexport class AuditService {\r\n  async logAudit(data: AuditLogData) {\r\n    try {\r\n      await prisma.auditLog.create({\r\n        data: {\r\n          action: data.action,\r\n          actorId: data.actorId,\r\n          targetType: data.targetType,\r\n          targetId: data.targetId,\r\n          metadata: data.metadata || {},\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error(\"Failed to write audit log:\", error);\r\n    }\r\n  }\r\n}\r\n\r\nexport const auditService = new AuditService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\auth.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\booking.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1901,1904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1901,1904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3176,3179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3176,3179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4372,4375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4372,4375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import nodemailer from \"nodemailer\";\r\nimport { env } from \"../config/env\";\r\n\r\nexport interface EmailOptions {\r\n  to: string;\r\n  subject: string;\r\n  html: string;\r\n}\r\n\r\nclass NotificationService {\r\n  private transporter: nodemailer.Transporter | null = null;\r\n\r\n  private async getTransporter() {\r\n    if (this.transporter) return this.transporter;\r\n\r\n    if (env.SMTP_HOST && env.SMTP_USER && env.SMTP_PASS) {\r\n      // Use configured SMTP\r\n      this.transporter = nodemailer.createTransport({\r\n        host: env.SMTP_HOST,\r\n        port: parseInt(env.SMTP_PORT || \"587\"),\r\n        secure: env.SMTP_PORT === \"465\",\r\n        auth: {\r\n          user: env.SMTP_USER,\r\n          pass: env.SMTP_PASS,\r\n        },\r\n      });\r\n    } else {\r\n      // Fallback to Ethereal Mail (Real emails, but trapped in a dev mailbox)\r\n      console.log(\"⚠️ No SMTP config found. Generating Ethereal testing account...\");\r\n      const testAccount = await nodemailer.createTestAccount();\r\n      this.transporter = nodemailer.createTransport({\r\n        host: \"smtp.ethereal.email\",\r\n        port: 587,\r\n        secure: false,\r\n        auth: {\r\n          user: testAccount.user,\r\n          pass: testAccount.pass,\r\n        },\r\n      });\r\n    }\r\n\r\n    return this.transporter;\r\n  }\r\n\r\n  async sendEmail(options: EmailOptions) {\r\n    try {\r\n      const transporter = await this.getTransporter();\r\n      const info = await transporter.sendMail({\r\n        from: env.SMTP_FROM,\r\n        ...options,\r\n      });\r\n\r\n      console.log(`✉️ Notification sent: ${info.messageId}`);\r\n      if (!env.SMTP_HOST) {\r\n        console.log(`🔗 Preview URL: ${nodemailer.getTestMessageUrl(info)}`);\r\n      }\r\n      return info;\r\n    } catch (error) {\r\n      console.error(\"❌ Failed to send email notification:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Pre-defined templates\r\n  async sendBookingConfirmation(email: string, bookingDetails: any) {\r\n    const html = `\r\n      <div style=\"font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #eee;\">\r\n        <h2 style=\"color: #f97316;\">Adventure Awaits! 🏔️</h2>\r\n        <p>Hi <strong>${bookingDetails.userName}</strong>,</p>\r\n        <p>Your booking for <strong>${bookingDetails.tripTitle}</strong> has been received and is currently <strong>${bookingDetails.status}</strong>.</p>\r\n        <div style=\"background: #fdf2f8; padding: 15px; border-radius: 8px; margin: 20px 0;\">\r\n          <p style=\"margin: 0;\"><strong>Order ID:</strong> #${bookingDetails.bookingId.substring(0, 8)}</p>\r\n          <p style=\"margin: 5px 0 0 0;\"><strong>Date:</strong> ${new Date(bookingDetails.startDate).toLocaleDateString()}</p>\r\n        </div>\r\n        <p>Once your payment is verified, we'll send you a confirmation with more details.</p>\r\n        <hr style=\"border: none; border-top: 1px solid #eee; margin: 20px 0;\" />\r\n        <p style=\"font-size: 12px; color: #666;\">Param Adventures — Premium Travel Experiences</p>\r\n      </div>\r\n    `;\r\n    return this.sendEmail({\r\n      to: email,\r\n      subject: `Booking Received: ${bookingDetails.tripTitle}`,\r\n      html,\r\n    });\r\n  }\r\n\r\n  async sendPaymentSuccess(email: string, paymentDetails: any) {\r\n    const html = `\r\n      <div style=\"font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #eee;\">\r\n        <h2 style=\"color: #22c55e;\">Payment Confirmed! ✅</h2>\r\n        <p>Hi <strong>${paymentDetails.userName}</strong>,</p>\r\n        <p>We've successfully processed your payment for <strong>${paymentDetails.tripTitle}</strong>.</p>\r\n        <div style=\"background: #f0fdf4; padding: 15px; border-radius: 8px; margin: 20px 0;\">\r\n          <p style=\"margin: 0;\"><strong>Booking Status:</strong> CONFIRMED</p>\r\n          <p style=\"margin: 5px 0 0 0;\"><strong>Amount Paid:</strong> ₹${paymentDetails.amount}</p>\r\n        </div>\r\n        <p>Get ready for an unforgettable journey! You can view your booking details in your dashboard.</p>\r\n        <hr style=\"border: none; border-top: 1px solid #eee; margin: 20px 0;\" />\r\n        <p style=\"font-size: 12px; color: #666;\">Param Adventures — Premium Travel Experiences</p>\r\n      </div>\r\n    `;\r\n    return this.sendEmail({\r\n      to: email,\r\n      subject: `Payment Confirmed: ${paymentDetails.tripTitle}`,\r\n      html,\r\n    });\r\n  }\r\n\r\n  async sendAssignmentNotification(email: string, assignmentDetails: any) {\r\n    const html = `\r\n      <div style=\"font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #eee;\">\r\n        <h2 style=\"color: #6366f1;\">New Assignment! 📋</h2>\r\n        <p>Hi <strong>${assignmentDetails.userName}</strong>,</p>\r\n        <p>You have been assigned as a <strong>${assignmentDetails.role}</strong> for the upcoming trip: <strong>${assignmentDetails.tripTitle}</strong>.</p>\r\n        <div style=\"background: #eef2ff; padding: 15px; border-radius: 8px; margin: 20px 0;\">\r\n          <p style=\"margin: 0;\"><strong>Trip:</strong> ${assignmentDetails.tripTitle}</p>\r\n          <p style=\"margin: 5px 0 0 0;\"><strong>Role:</strong> ${assignmentDetails.role}</p>\r\n        </div>\r\n        <p>Please log in to your dashboard to view the trip logistics and guest list.</p>\r\n        <hr style=\"border: none; border-top: 1px solid #eee; margin: 20px 0;\" />\r\n        <p style=\"font-size: 12px; color: #666;\">Param Adventures — Premium Travel Experiences</p>\r\n      </div>\r\n    `;\r\n    return this.sendEmail({\r\n      to: email,\r\n      subject: `New Assignment: ${assignmentDetails.tripTitle}`,\r\n      html,\r\n    });\r\n  }\r\n\r\n  async sendPasswordResetEmail(email: string, resetLink: string) {\r\n    const html = `\r\n      <div style=\"font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #eee;\">\r\n        <h2 style=\"color: #ef4444;\">Reset Your Password 🔒</h2>\r\n        <p>We received a request to reset your password. If you didn't make this request, you can safely ignore this email.</p>\r\n        <p>Click the button below to reset your password:</p>\r\n        <div style=\"margin: 20px 0;\">\r\n          <a href=\"${resetLink}\" style=\"background: #ef4444; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block; font-weight: bold;\">Reset Password</a>\r\n        </div>\r\n        <p style=\"font-size: 12px; color: #666;\">This link expires in 15 minutes.</p>\r\n        <hr style=\"border: none; border-top: 1px solid #eee; margin: 20px 0;\" />\r\n        <p style=\"font-size: 12px; color: #666;\">Param Adventures — Premium Travel Experiences</p>\r\n      </div>\r\n    `;\r\n    return this.sendEmail({ to: email, subject: \"Reset Your Password\", html });\r\n  }\r\n}\r\n\r\nexport const notificationService = new NotificationService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\razorpay.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\trip.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[336,339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[336,339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[733,736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[733,736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1913,1916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1913,1916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2349,2352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2349,2352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from \"../lib/prisma\";\r\nimport { auditService } from \"./audit.service\";\r\n\r\nexport class TripService {\r\n  /**\r\n   * Creates a new trip and logs the action.\r\n   * @param data The trip data.\r\n   * @param userId The ID of the user creating the trip.\r\n   * @returns The created trip object.\r\n   */\r\n  async createTrip(data: any, userId: string) {\r\n    const trip = await prisma.trip.create({\r\n      data: {\r\n        ...data,\r\n        startDate: data.startDate ? new Date(data.startDate) : null,\r\n        endDate: data.endDate ? new Date(data.endDate) : null,\r\n        createdById: userId,\r\n        gallery:\r\n          data.gallery && data.gallery.length > 0\r\n            ? {\r\n                create: data.gallery.map((g: any, index: number) => ({\r\n                  imageId: g.id,\r\n                  order: index,\r\n                })),\r\n              }\r\n            : undefined,\r\n      },\r\n      include: {\r\n        coverImage: true,\r\n        gallery: {\r\n          include: { image: true },\r\n          orderBy: { order: \"asc\" },\r\n        },\r\n      },\r\n    });\r\n\r\n    await auditService.logAudit({\r\n      actorId: userId,\r\n      action: \"TRIP_CREATED\",\r\n      targetType: \"TRIP\",\r\n      targetId: trip.id,\r\n      metadata: { status: trip.status },\r\n    });\r\n\r\n    return trip;\r\n  }\r\n\r\n  /**\r\n   * Fetches a trip by its slug with relations.\r\n   * @param slug The trip slug.\r\n   * @returns The trip object or null if not found.\r\n   */\r\n  async getTripBySlug(slug: string) {\r\n    return prisma.trip.findUnique({\r\n      where: { slug },\r\n      include: {\r\n        coverImage: true,\r\n        heroImage: true,\r\n        gallery: {\r\n          include: {\r\n            image: true,\r\n          },\r\n          orderBy: {\r\n            order: \"asc\",\r\n          },\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Logic for updating an existing trip (to be implemented).\r\n   */\r\n  async updateTrip(id: string, data: any, userId: string) {\r\n    // Basic implementation for now, mirroring createTrip logic\r\n    const trip = await prisma.trip.update({\r\n      where: { id },\r\n      data: {\r\n        ...data,\r\n        startDate: data.startDate ? new Date(data.startDate) : undefined,\r\n        endDate: data.endDate ? new Date(data.endDate) : undefined,\r\n        gallery: data.gallery ? {\r\n           deleteMany: {},\r\n           create: data.gallery.map((g: any, index: number) => ({\r\n             imageId: g.id,\r\n             order: index,\r\n           }))\r\n        } : undefined\r\n      }\r\n    });\r\n\r\n    await auditService.logAudit({\r\n      actorId: userId,\r\n      action: \"TRIP_UPDATED\",\r\n      targetType: \"TRIP\",\r\n      targetId: trip.id,\r\n    });\r\n\r\n    return trip;\r\n  }\r\n}\r\n\r\nexport const tripService = new TripService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\services\\user.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[414,417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[414,417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1220,1223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1220,1223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1321,1324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1321,1324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1371,1374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1371,1374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2106,2109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2106,2109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2153,2156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2153,2156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from \"../lib/prisma\";\r\nimport { auditService } from \"./audit.service\";\r\n\r\nexport class UserService {\r\n  /**\r\n   * Fetches a user by ID with their roles and permissions.\r\n   * @param userId The ID of the user to fetch.\r\n   * @returns The user object with roles and permissions, or null if not found.\r\n   */\r\n  async getUserWithPermissions(userId: string) {\r\n    const user = await (prisma.user as any).findUnique({\r\n      where: { id: userId },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        nickname: true,\r\n        bio: true,\r\n        age: true,\r\n        gender: true,\r\n        phoneNumber: true,\r\n        address: true,\r\n        status: true,\r\n        createdAt: true,\r\n        avatarImage: true,\r\n        preferences: true,\r\n        roles: {\r\n          select: {\r\n            role: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                permissions: {\r\n                  include: {\r\n                    permission: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!user) return null;\r\n\r\n    const roles = user.roles.map((r: any) => r.role.name);\r\n    const permissions = new Set<string>();\r\n    \r\n    user.roles.forEach((ur: any) => {\r\n      ur.role.permissions.forEach((rp: any) => {\r\n        permissions.add(rp.permission.key);\r\n      });\r\n    });\r\n\r\n    return {\r\n      ...user,\r\n      roles,\r\n      permissions: Array.from(permissions),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Checks if a user has a specific permission.\r\n   * @param userId The ID of the user.\r\n   * @param permissionKey The permission key to check.\r\n   * @returns True if the user has the permission, false otherwise.\r\n   */\r\n  async hasPermission(userId: string, permissionKey: string) {\r\n    const user = await this.getUserWithPermissions(userId);\r\n    if (!user) return false;\r\n    return user.permissions.includes(permissionKey);\r\n  }\r\n  /**\r\n   * Updates a user's profile and logs the action.\r\n   */\r\n  async updateProfile(userId: string, data: any) {\r\n    const user = await (prisma.user as any).update({\r\n      where: { id: userId },\r\n      data: {\r\n        name: data.name,\r\n        nickname: data.nickname,\r\n        bio: data.bio,\r\n        age: data.age ? Number(data.age) : null,\r\n        gender: data.gender,\r\n        phoneNumber: data.phoneNumber,\r\n        address: data.address,\r\n        avatarImageId: data.avatarImageId,\r\n        preferences: data.preferences,\r\n      },\r\n      include: {\r\n        avatarImage: true,\r\n      },\r\n    });\r\n\r\n    await auditService.logAudit({\r\n      actorId: userId,\r\n      action: \"USER_UPDATE_PROFILE\",\r\n      targetType: \"User\",\r\n      targetId: userId,\r\n    });\r\n\r\n    return user;\r\n  }\r\n}\r\n\r\nexport const userService = new UserService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\types\\auth-modules.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\types\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\types\\express.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\ApiResponse.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[122,125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[122,125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[351,354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[351,354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Response } from \"express\";\r\n\r\nexport class ApiResponse {\r\n  static success(res: Response, message: string, data: any = {}, statusCode: number = 200) {\r\n    return res.status(statusCode).json({\r\n      success: true,\r\n      message,\r\n      data,\r\n    });\r\n  }\r\n\r\n  static error(res: Response, message: string, statusCode: number = 500, errors: any = null) {\r\n    return res.status(statusCode).json({\r\n      success: false,\r\n      message,\r\n      ...(errors && { errors }),\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\catchAsync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[158,161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[158,161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from \"express\";\r\n\r\nexport const catchAsync = (\r\n  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>,\r\n) => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    fn(req, res, next).catch(next);\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\cookie.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\httpError.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\httpError.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\imageProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\jwt.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[260,263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[260,263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[486,489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[486,489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as jwt from \"jsonwebtoken\";\r\nimport { env } from \"../config/env\";\r\n\r\nexport interface JwtPayload {\r\n  sub: string; // userId\r\n}\r\n\r\nexport function signAccessToken(userId: string) {\r\n  const opts: jwt.SignOptions = { expiresIn: env.ACCESS_TOKEN_TTL as any };\r\n  return jwt.sign({ sub: userId }, env.JWT_ACCESS_SECRET as unknown as jwt.Secret, opts);\r\n}\r\n\r\nexport function signRefreshToken(userId: string) {\r\n  const opts: jwt.SignOptions = { expiresIn: env.REFRESH_TOKEN_TTL as any };\r\n  return jwt.sign({ sub: userId }, env.JWT_REFRESH_SECRET as unknown as jwt.Secret, opts);\r\n}\r\n\r\nexport function verifyAccessToken(token: string) {\r\n  return jwt.verify(token, env.JWT_ACCESS_SECRET) as JwtPayload;\r\n}\r\n\r\nexport function verifyRefreshToken(token: string) {\r\n  return jwt.verify(token, env.JWT_REFRESH_SECRET) as JwtPayload;\r\n}\r\n\r\nexport function signResetToken(userId: string) {\r\n  return jwt.sign(\r\n    { sub: userId },\r\n    env.JWT_ACCESS_SECRET as unknown as jwt.Secret, // Resusing access secret for now, ideally dedicated secret\r\n    { expiresIn: \"15m\" },\r\n  );\r\n}\r\n\r\nexport function verifyResetToken(token: string) {\r\n  return jwt.verify(token, env.JWT_ACCESS_SECRET) as JwtPayload;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\mediaProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":107,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":110,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[487,490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[487,490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { cloudinary } from \"../config/cloudinary\";\r\nimport stream from \"stream\";\r\n\r\nexport type ProcessedMedia = {\r\n  originalUrl: string;\r\n  mediumUrl: string;\r\n  thumbUrl: string;\r\n  width: number;\r\n  height: number;\r\n  size: number;\r\n  mimeType: string;\r\n  type: \"IMAGE\" | \"VIDEO\";\r\n  duration: number; // in seconds, 0 if unknown\r\n};\r\n\r\n// Helper: Upload Buffer to Cloudinary\r\nfunction uploadBuffer(buffer: Buffer, folder: string, resourceType: \"image\" | \"video\" = \"image\"): Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    const uploadStream = cloudinary.uploader.upload_stream(\r\n      {\r\n        folder,\r\n        resource_type: resourceType,\r\n      },\r\n      (error, result) => {\r\n        if (error) return reject(error);\r\n        resolve(result);\r\n      }\r\n    );\r\n    const bufferStream = new stream.PassThrough();\r\n    bufferStream.end(buffer);\r\n    bufferStream.pipe(uploadStream);\r\n  });\r\n}\r\n\r\nexport async function processMedia(buffer: Buffer, mimeType: string): Promise<ProcessedMedia> {\r\n  if (mimeType.startsWith(\"image/\")) {\r\n    return processImage(buffer, mimeType);\r\n  } else if (mimeType.startsWith(\"video/\")) {\r\n    return processVideo(buffer, mimeType);\r\n  } else {\r\n    throw new Error(\"UNSUPPORTED_MEDIA_TYPE\");\r\n  }\r\n}\r\n\r\nasync function processImage(buffer: Buffer, mimeType: string): Promise<ProcessedMedia> {\r\n  // Upload Original File to Cloudinary\r\n  // Cloudinary automatically detects dimensions and size\r\n  const result = await uploadBuffer(buffer, \"param_adventures_uploads/images\", \"image\");\r\n\r\n  // Generate Transformed URLs using Public ID\r\n  // Medium: Max 1200px width\r\n  const mediumUrl = cloudinary.url(result.public_id, {\r\n    width: 1200,\r\n    crop: \"limit\",\r\n    secure: true,\r\n  });\r\n\r\n  // Thumb: 400x400 fill (good for avatars/grids)\r\n  const thumbUrl = cloudinary.url(result.public_id, {\r\n    width: 400,\r\n    height: 400,\r\n    crop: \"fill\",\r\n    gravity: \"auto\", // Focus on interesting part (face/object)\r\n    secure: true,\r\n  });\r\n\r\n  return {\r\n    originalUrl: result.secure_url,\r\n    mediumUrl: mediumUrl,\r\n    thumbUrl: thumbUrl,\r\n    width: result.width,\r\n    height: result.height,\r\n    size: result.bytes,\r\n    mimeType: result.format ? `image/${result.format}` : mimeType,\r\n    type: \"IMAGE\",\r\n    duration: 0,\r\n  };\r\n}\r\n\r\nasync function processVideo(buffer: Buffer, mimeType: string): Promise<ProcessedMedia> {\r\n  // Upload Video\r\n  const result = await uploadBuffer(buffer, \"param_adventures_uploads/videos\", \"video\");\r\n\r\n  return {\r\n    originalUrl: result.secure_url,\r\n    mediumUrl: result.secure_url, // Cloudinary can also resize videos if needed\r\n    thumbUrl: result.secure_url, // Or use result.public_id + \".jpg\" for poster\r\n    width: result.width,\r\n    height: result.height,\r\n    size: result.bytes,\r\n    mimeType: mimeType,\r\n    type: \"VIDEO\",\r\n    duration: result.duration || 0,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\password.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\roleGuards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\slugify.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\src\\utils\\webhookLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\globalTeardown.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\helpers\\prisma.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\admin.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\admin_analytics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\auth.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[563,566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[563,566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[708,711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[708,711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[902,905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[902,905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1041,1044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1041,1044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1184,1187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1184,1187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1329,1332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1329,1332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1471,1474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1471,1474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1616,1619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1616,1619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1763,1766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1763,1766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1916,1919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1916,1919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2070,2073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2070,2073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2214,2217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2214,2217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2352,2355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2352,2355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import request from \"supertest\";\r\nimport { app } from \"../../src/app\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport { writeFileSync } from \"fs\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\ndescribe(\"Auth Integration\", () => {\r\n  beforeAll(async () => {\r\n    // Clean up DB before tests - respecting FKs\r\n    // Delete join tables first if they exist (assuming schema structure)\r\n    // Or simpler: delete everything.\r\n    // Safe order based on schema:\r\n    // Dependent models first\r\n    try {\r\n      await prisma.payment?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing payment:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.booking?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing booking:\", e.message);\r\n    }\r\n    // tripGalleryImage is cascade deleted by Trip\r\n    try {\r\n      await prisma.blog?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing blog:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.trip?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing trip:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.savedTrip.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing savedTrip:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.review.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing review:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.image?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing image:\", e.message);\r\n    }\r\n\r\n    try {\r\n      await prisma.auditLog.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing auditLog:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.userRole?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing userRole:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.rolePermission?.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing rolePermission:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.permission.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing permission:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.role.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing role:\", e.message);\r\n    }\r\n    try {\r\n      await prisma.user.deleteMany();\r\n    } catch (e: any) {\r\n      console.error(\"Error clearing user:\", e.message);\r\n    }\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await prisma.$disconnect();\r\n  });\r\n\r\n  it(\"should register a new user\", async () => {\r\n    const res = await request(app).post(\"/auth/register\").send({\r\n      email: \"test@example.com\",\r\n      password: \"Password123!\",\r\n      name: \"Test User\",\r\n    });\r\n\r\n    if (res.status !== 201) {\r\n      writeFileSync(\"auth-debug.log\", `Status: ${res.status}, Body: ${JSON.stringify(res.body)}`);\r\n    }\r\n\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.data.user).toHaveProperty(\"id\");\r\n    expect(res.body.data.user.email).toBe(\"test@example.com\");\r\n\r\n    // Verify DB\r\n    const user = await prisma.user.findUnique({\r\n      where: { email: \"test@example.com\" },\r\n    });\r\n    expect(user).toBeTruthy();\r\n  });\r\n\r\n  it(\"should fail on duplicate email\", async () => {\r\n    const res = await request(app).post(\"/auth/register\").send({\r\n      email: \"test@example.com\",\r\n      password: \"Password123!\",\r\n      name: \"Test User 2\",\r\n    });\r\n\r\n    expect(res.status).toBe(409);\r\n    expect(res.body.error.message).toBe(\"Email already registered\");\r\n  });\r\n\r\n  it(\"should fail on invalid email (Zod)\", async () => {\r\n    const res = await request(app).post(\"/auth/register\").send({\r\n      email: \"invalid-email\",\r\n      password: \"Password123!\",\r\n      name: \"Test User\",\r\n    });\r\n\r\n    expect(res.status).toBe(400);\r\n    expect(res.body.error).toBe(\"Validation failed\");\r\n  });\r\n\r\n  describe(\"Session & Refresh\", () => {\r\n    const credentials = {\r\n      email: \"session@example.com\",\r\n      password: \"Password123!\",\r\n      name: \"Session User\",\r\n    };\r\n\r\n    beforeAll(async () => {\r\n      await request(app).post(\"/auth/register\").send(credentials);\r\n    });\r\n\r\n    it(\"should login successfully and return access token + user\", async () => {\r\n      const res = await request(app).post(\"/auth/login\").send({\r\n        email: credentials.email,\r\n        password: credentials.password,\r\n      });\r\n\r\n      expect(res.status).toBe(200);\r\n      expect(res.body.data).toHaveProperty(\"accessToken\");\r\n      expect(res.body.data).toHaveProperty(\"user\");\r\n      expect(res.body.data.user.email).toBe(credentials.email);\r\n      expect(res.headers[\"set-cookie\"]).toBeDefined();\r\n    });\r\n\r\n    it(\"should fail login with wrong password\", async () => {\r\n      const res = await request(app).post(\"/auth/login\").send({\r\n        email: credentials.email,\r\n        password: \"wrongpassword\",\r\n      });\r\n\r\n      expect(res.status).toBe(401);\r\n      expect(res.body.error.message).toContain(\"Invalid credentials\");\r\n    });\r\n\r\n    it(\"should get current user profile with valid token\", async () => {\r\n      const loginRes = await request(app).post(\"/auth/login\").send({\r\n        email: credentials.email,\r\n        password: credentials.password,\r\n      });\r\n      const token = loginRes.body.data.accessToken;\r\n\r\n      const res = await request(app).get(\"/auth/me\").set(\"Authorization\", `Bearer ${token}`);\r\n\r\n      expect(res.status).toBe(200);\r\n      expect(res.body.data.email).toBe(credentials.email);\r\n    });\r\n\r\n    it(\"should refresh access token using cookie\", async () => {\r\n      const loginRes = await request(app).post(\"/auth/login\").send({\r\n        email: credentials.email,\r\n        password: credentials.password,\r\n      });\r\n      const cookies = loginRes.headers[\"set-cookie\"];\r\n\r\n      const res = await request(app).post(\"/auth/refresh\").set(\"Cookie\", cookies);\r\n\r\n      expect(res.status).toBe(200);\r\n      expect(res.body.data).toHaveProperty(\"accessToken\");\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\auth_helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\booking.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[552,555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[552,555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import request from \"supertest\";\r\nimport { app } from \"../../src/app\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport { signAccessToken } from \"../../src/utils/jwt\";\r\nimport { notificationQueue } from \"../../src/lib/queue\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\ndescribe(\"Booking Integration\", () => {\r\n  let userToken: string;\r\n  let userId: string;\r\n  let tripId: string;\r\n\r\n  beforeAll(async () => {\r\n    // Spy on queue to prevent actual Redis jobs and potential errors\r\n    jest.spyOn(notificationQueue, \"add\").mockResolvedValue({} as any);\r\n\r\n    // Clean up\r\n    try {\r\n      await prisma.review.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.savedTrip.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.blog.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.payment.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.booking.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.trip.deleteMany();\r\n    } catch { /* ignored */ }\r\n    try {\r\n      await prisma.user.deleteMany();\r\n    } catch { /* ignored */ }\r\n\r\n    // Create user\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email: \"booker@test.com\",\r\n        password: \"Password123!\",\r\n        name: \"Booker User\",\r\n      },\r\n    });\r\n    userId = user.id;\r\n    userToken = signAccessToken(userId);\r\n\r\n    // Create trip\r\n    const trip = await prisma.trip.create({\r\n      data: {\r\n        title: \"Test Expedition\",\r\n        slug: \"test-expedition\",\r\n        description: \"A test trip\",\r\n        itinerary: {},\r\n        durationDays: 5,\r\n        difficulty: \"Moderate\",\r\n        location: \"Himalayas\",\r\n        price: 500,\r\n        status: \"PUBLISHED\",\r\n        capacity: 10,\r\n        createdById: userId,\r\n      },\r\n    });\r\n    tripId = trip.id;\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await prisma.$disconnect();\r\n    try {\r\n      await notificationQueue.close();\r\n    } catch (e) {\r\n      console.warn(\"Failed to close queue in tests:\", e);\r\n    }\r\n  });\r\n\r\n  it(\"should create a new booking\", async () => {\r\n    const res = await request(app)\r\n      .post(\"/bookings\")\r\n      .set(\"Authorization\", `Bearer ${userToken}`)\r\n      .send({\r\n        tripId,\r\n        startDate: new Date().toISOString(),\r\n        guests: 2,\r\n        notes: \"Excited for the trip!\",\r\n      });\r\n\r\n    if (res.status !== 201) {\r\n      console.log(\"Create Booking Error:\", JSON.stringify(res.body, null, 2));\r\n    }\r\n\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.data).toHaveProperty(\"id\");\r\n    expect(res.body.data.tripId).toBe(tripId);\r\n    expect(res.body.data.guests).toBe(2);\r\n  });\r\n\r\n  it(\"should get user's bookings\", async () => {\r\n    const res = await request(app)\r\n      .get(\"/bookings/me\")\r\n      .set(\"Authorization\", `Bearer ${userToken}`);\r\n\r\n    expect(res.status).toBe(200);\r\n    expect(Array.isArray(res.body.data)).toBe(true);\r\n    expect(res.body.data.length).toBeGreaterThan(0);\r\n    expect(res.body.data[0].trip.title).toBe(\"Test Expedition\");\r\n  });\r\n\r\n  it(\"should fail to create booking for non-existent trip\", async () => {\r\n    const res = await request(app)\r\n      .post(\"/bookings\")\r\n      .set(\"Authorization\", `Bearer ${userToken}`)\r\n      .send({\r\n        tripId: \"non-existent-id\",\r\n        startDate: new Date().toISOString(),\r\n        guests: 1,\r\n      });\r\n\r\n    expect(res.status).toBe(404);\r\n    // ApiResponse error structure: { error: { code, message } } or { error: message } depending on middleware\r\n    // Based on error.middleware.ts: res.status(status).json({ error: { code, message } })\r\n    // But catchAsync passes errors to middleware. Service checks trip existence and throws HttpError(404...).\r\n    expect(res.body.error).toBeDefined();\r\n  });\r\n\r\n  it(\"should cancel a booking\", async () => {\r\n    // First create a booking to cancel\r\n    const booking = await prisma.booking.create({\r\n      data: {\r\n        userId,\r\n        tripId,\r\n        startDate: new Date(),\r\n        guests: 1,\r\n        totalPrice: 500,\r\n      },\r\n    });\r\n\r\n    const res = await request(app)\r\n      .post(`/bookings/${booking.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${userToken}`);\r\n\r\n    expect(res.status).toBe(200);\r\n    \r\n    // Check wrapped response in data\r\n    // The controller returns: { booking: updatedBooking } inside data\r\n    expect(res.body.data.booking.status).toBe(\"CANCELLED\");\r\n\r\n    const updated = await prisma.booking.findUnique({ where: { id: booking.id } });\r\n    expect(updated?.status).toBe(\"CANCELLED\");\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\health.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\mock_check.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[424,427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[424,427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mockDeep } from \"jest-mock-extended\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\njest.mock(\"../../src/lib/prisma\", () => ({\r\n  __esModule: true,\r\n  prisma: mockDeep<PrismaClient>(),\r\n}));\r\n\r\nimport { prisma } from \"../../src/lib/prisma\";\r\n\r\ndescribe(\"Mock Check\", () => {\r\n  it(\"should have a mocked prisma\", () => {\r\n    expect(prisma.user.findUnique).toBeDefined();\r\n    expect((prisma.user.findUnique as any).mock).toBeDefined();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\payments.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\registration.mock.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[888,891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[888,891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1001,1004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1001,1004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1500,1503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1500,1503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mockDeep } from \"jest-mock-extended\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\njest.mock(\"../../src/lib/prisma\", () => ({\r\n  __esModule: true,\r\n  prisma: mockDeep<PrismaClient>(),\r\n}));\r\n\r\nimport request from \"supertest\";\r\nimport { app } from \"../../src/app\";\r\nimport { prismaMock } from \"../helpers/prisma.mock\";\r\n\r\ndescribe(\"User Registration Flow (Mocked)\", () => {\r\n  it(\"should register a new user successfully\", async () => {\r\n    const userData = {\r\n      id: \"user-123\",\r\n      email: \"newuser@example.com\",\r\n      name: \"New User\",\r\n      password: \"hashed_password\",\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    // Mock finding existing user (null means not found, OK to register)\r\n    prismaMock.user.findUnique.mockResolvedValue(null);\r\n    \r\n    // Mock user creation\r\n    prismaMock.user.create.mockResolvedValue(userData as any);\r\n\r\n    // Mock audit log creation\r\n    prismaMock.auditLog.create.mockResolvedValue({ id: \"audit-123\" } as any);\r\n\r\n    const res = await request(app).post(\"/auth/register\").send({\r\n      email: \"newuser@example.com\",\r\n      password: \"Password123!\",\r\n      name: \"New User\",\r\n    });\r\n\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.data.user).toHaveProperty(\"id\", \"user-123\");\r\n    expect(res.body.data.user.email).toBe(\"newuser@example.com\");\r\n  });\r\n\r\n  it(\"should fail if email is already registered\", async () => {\r\n    prismaMock.user.findUnique.mockResolvedValue({ id: \"existing-123\" } as any);\r\n\r\n    const res = await request(app).post(\"/auth/register\").send({\r\n      email: \"existing@example.com\",\r\n      password: \"Password123!\",\r\n      name: \"Existing User\",\r\n    });\r\n\r\n    expect(res.status).toBe(409); \r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\trip_creation.mock.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1326,1329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1326,1329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1422,1425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1422,1425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1526,1529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1526,1529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2053,2056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2053,2056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mockDeep } from \"jest-mock-extended\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\njest.mock(\"../../src/lib/prisma\", () => ({\r\n  __esModule: true,\r\n  prisma: mockDeep<PrismaClient>(),\r\n}));\r\n\r\nimport request from \"supertest\";\r\nimport { app } from \"../../src/app\";\r\nimport { prismaMock } from \"../helpers/prisma.mock\";\r\nimport { generateAuthToken } from \"./auth_helper\";\r\n\r\ndescribe(\"Trip Creation Flow (Mocked)\", () => {\r\n  const userId = \"admin-123\";\r\n  const token = generateAuthToken(userId);\r\n\r\n  it(\"should create a new trip successfully\", async () => {\r\n    const tripData = {\r\n      title: \"Adventure Trip\",\r\n      slug: \"adventure-trip\",\r\n      description: \"Exciting adventure\",\r\n      price: 1000,\r\n    };\r\n\r\n    const createdTrip = {\r\n      id: \"trip-123\",\r\n      ...tripData,\r\n      status: \"DRAFT\",\r\n      createdById: userId,\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    // Mock permission check (dbUser lookup)\r\n    prismaMock.user.findUnique.mockResolvedValue({\r\n      id: userId,\r\n      status: \"ACTIVE\",\r\n      roles: [\r\n        {\r\n          role: {\r\n            name: \"ADMIN\",\r\n            permissions: [\r\n              {\r\n                permission: {\r\n                  key: \"trip:create\",\r\n                },\r\n              },\r\n            ],\r\n          },\r\n        },\r\n      ],\r\n    } as any);\r\n\r\n    // Mock trip creation\r\n    prismaMock.trip.create.mockResolvedValue(createdTrip as any);\r\n\r\n    // Mock audit log\r\n    prismaMock.auditLog.create.mockResolvedValue({ id: \"audit-123\" } as any);\r\n\r\n    const res = await request(app)\r\n      .post(\"/trips\")\r\n      .set(\"Authorization\", `Bearer ${token}`)\r\n      .send(tripData);\r\n\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.data).toHaveProperty(\"id\", \"trip-123\");\r\n    expect(res.body.data.title).toBe(\"Adventure Trip\");\r\n  });\r\n\r\n  it(\"should fail without permission\", async () => {\r\n    // Mock user without required permission\r\n    prismaMock.user.findUnique.mockResolvedValue({\r\n      id: userId,\r\n      status: \"ACTIVE\",\r\n      roles: [],\r\n    } as any);\r\n\r\n    const res = await request(app)\r\n      .post(\"/trips\")\r\n      .set(\"Authorization\", `Bearer ${token}`)\r\n      .send({ title: \"No Permission Trip\" });\r\n\r\n    expect(res.status).toBe(403);\r\n    expect(res.body.error.message).toContain(\"permission\");\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\integration\\user_profile.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\unit\\auth.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1148,1151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1148,1151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { authService } from \"../../src/services/auth.service\";\r\nimport { prisma } from \"../../src/lib/prisma\";\r\nimport { hashPassword, verifyPassword } from \"../../src/utils/password\";\r\nimport { signAccessToken, signRefreshToken } from \"../../src/utils/jwt\";\r\nimport { auditService } from \"../../src/services/audit.service\";\r\n\r\njest.mock(\"../../src/lib/prisma\", () => ({\r\n  prisma: {\r\n    user: {\r\n      findUnique: jest.fn(),\r\n      create: jest.fn(),\r\n      update: jest.fn(),\r\n    },\r\n  },\r\n}));\r\n\r\njest.mock(\"../../src/utils/password\", () => ({\r\n  hashPassword: jest.fn(),\r\n  verifyPassword: jest.fn(),\r\n}));\r\n\r\njest.mock(\"../../src/utils/jwt\", () => ({\r\n  signAccessToken: jest.fn(),\r\n  signRefreshToken: jest.fn(),\r\n  verifyRefreshToken: jest.fn(),\r\n  signResetToken: jest.fn(),\r\n  verifyResetToken: jest.fn(),\r\n}));\r\n\r\njest.mock(\"../../src/services/audit.service\", () => ({\r\n  auditService: {\r\n    logAudit: jest.fn(),\r\n  },\r\n}));\r\n\r\njest.mock(\"../../src/services/notification.service\", () => ({\r\n  notificationService: {\r\n    sendPasswordResetEmail: jest.fn(),\r\n  },\r\n}));\r\n\r\ndescribe(\"AuthService\", () => {\r\n  const prismaMock = prisma as any;\r\n\r\n  beforeEach(() => {\r\n    jest.clearAllMocks();\r\n  });\r\n\r\n  describe(\"register\", () => {\r\n    it(\"should register successfully\", async () => {\r\n      const data = { email: \"a@b.com\", password: \"p\", name: \"n\" };\r\n      prismaMock.user.findUnique.mockResolvedValue(null);\r\n      (hashPassword as jest.Mock).mockResolvedValue(\"hashed\");\r\n      prismaMock.user.create.mockResolvedValue({ id: \"1\", ...data });\r\n\r\n      const res = await authService.register(data);\r\n      expect(res.id).toBe(\"1\");\r\n      expect(prismaMock.user.create).toHaveBeenCalled();\r\n    });\r\n  });\r\n\r\n  describe(\"login\", () => {\r\n    it(\"should login successfully\", async () => {\r\n      const user = { id: \"1\", email: \"a@b.com\", password: \"hp\" };\r\n      prismaMock.user.findUnique.mockResolvedValue(user);\r\n      (verifyPassword as jest.Mock).mockResolvedValue(true);\r\n      (signAccessToken as jest.Mock).mockReturnValue(\"at\");\r\n      (signRefreshToken as jest.Mock).mockReturnValue(\"rt\");\r\n      (auditService.logAudit as jest.Mock).mockResolvedValue({});\r\n\r\n      const res = await authService.login(\"a@b.com\", \"p\");\r\n      expect(res.accessToken).toBe(\"at\");\r\n      expect(res.user.id).toBe(\"1\");\r\n    });\r\n\r\n    it(\"should fail with invalid creds\", async () => {\r\n      prismaMock.user.findUnique.mockResolvedValue(null);\r\n      await expect(authService.login(\"a\", \"p\")).rejects.toThrow(\"Invalid credentials\");\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\unit\\booking.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[663,666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[663,666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"jest.mock(\"../../src/lib/prisma\", () => ({\r\n  __esModule: true,\r\n  prisma: {\r\n    trip: {\r\n      findUnique: jest.fn(),\r\n    },\r\n    booking: {\r\n      create: jest.fn(),\r\n      findUnique: jest.fn(),\r\n      update: jest.fn(),\r\n      findMany: jest.fn(),\r\n    },\r\n    $connect: jest.fn(),\r\n    $disconnect: jest.fn(),\r\n  },\r\n}));\r\n\r\njest.mock(\"../../src/lib/queue\", () => ({\r\n  notificationQueue: {\r\n    add: jest.fn().mockResolvedValue({}),\r\n  },\r\n}));\r\n\r\nimport { bookingService } from \"../../src/services/booking.service\";\r\nimport { prisma } from \"../../src/lib/prisma\";\r\nimport { notificationQueue } from \"../../src/lib/queue\";\r\n\r\nconst prismaMock = prisma as any;\r\n\r\ndescribe(\"BookingService\", () => {\r\n  beforeEach(() => {\r\n    jest.clearAllMocks();\r\n  });\r\n\r\n  describe(\"createBooking\", () => {\r\n    it(\"should create a booking successfully\", async () => {\r\n      const bookingData = {\r\n        userId: \"user-1\",\r\n        tripId: \"trip-1\",\r\n        startDate: \"2024-01-01\",\r\n        guests: 2,\r\n      };\r\n      const mockTrip = {\r\n        id: \"trip-1\",\r\n        price: 100,\r\n        status: \"PUBLISHED\",\r\n        title: \"Test Trip\",\r\n        slug: \"test-trip\",\r\n      };\r\n\r\n      prismaMock.trip.findUnique.mockResolvedValue(mockTrip);\r\n      prismaMock.booking.create.mockResolvedValue({\r\n        id: \"booking-1\",\r\n        ...bookingData,\r\n        totalPrice: 200,\r\n        status: \"REQUESTED\",\r\n        trip: { title: \"Test Trip\", slug: \"test-trip\" },\r\n      });\r\n\r\n      const result = await bookingService.createBooking(bookingData);\r\n\r\n      expect(result.id).toBe(\"booking-1\");\r\n      expect(result.totalPrice).toBe(200);\r\n      expect(prismaMock.booking.create).toHaveBeenCalled();\r\n      expect(notificationQueue.add).toHaveBeenCalled();\r\n    });\r\n\r\n    it(\"should throw error if trip not found\", async () => {\r\n      prismaMock.trip.findUnique.mockResolvedValue(null);\r\n      await expect(\r\n        bookingService.createBooking({ userId: \"u1\", tripId: \"t1\", startDate: \"2024\", guests: 1 }),\r\n      ).rejects.toThrow(\"Trip not found\");\r\n    });\r\n\r\n    it(\"should throw error if trip is not published\", async () => {\r\n      prismaMock.trip.findUnique.mockResolvedValue({ status: \"DRAFT\" });\r\n      await expect(\r\n        bookingService.createBooking({ userId: \"u1\", tripId: \"t1\", startDate: \"2024\", guests: 1 }),\r\n      ).rejects.toThrow(\"Trip is not available for booking\");\r\n    });\r\n  });\r\n\r\n  describe(\"cancelBooking\", () => {\r\n    it(\"should cancel a booking successfully\", async () => {\r\n      const mockBooking = { id: \"b1\", userId: \"u1\", status: \"REQUESTED\" };\r\n      prismaMock.booking.findUnique.mockResolvedValue(mockBooking);\r\n      prismaMock.booking.update.mockResolvedValue({ ...mockBooking, status: \"CANCELLED\" });\r\n\r\n      const result = await bookingService.cancelBooking(\"b1\", \"u1\");\r\n\r\n      expect(result.status).toBe(\"CANCELLED\");\r\n      expect(prismaMock.booking.update).toHaveBeenCalledWith({\r\n        where: { id: \"b1\" },\r\n        data: { status: \"CANCELLED\" },\r\n      });\r\n    });\r\n\r\n    it(\"should throw error if unauthorized\", async () => {\r\n      prismaMock.booking.findUnique.mockResolvedValue({ id: \"b1\", userId: \"other\" });\r\n      await expect(bookingService.cancelBooking(\"b1\", \"u1\")).rejects.toThrow(\"Unauthorized\");\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\unit\\inquiry.controller.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[842,845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[842,845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { mockDeep } from \"jest-mock-extended\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\n// 1. Setup Mock\r\nconst prismaMock = mockDeep<PrismaClient>();\r\n\r\njest.mock(\"../../src/lib/prisma\", () => ({\r\n  __esModule: true,\r\n  prisma: prismaMock,\r\n}));\r\n\r\n// 2. Import Controller (Must be after mock definition if using doMock, but jest.mock should hoist. \r\n// However, separating it helps clarity and safety with internal modules)\r\nimport { createInquiry } from \"../../src/controllers/inquiry.controller\";\r\n\r\n// Mocking Response methods\r\nconst mockResponse = () => {\r\n  const res: Partial<Response> = {};\r\n  res.status = jest.fn().mockReturnValue(res);\r\n  res.json = jest.fn().mockReturnValue(res);\r\n  return res as Response;\r\n};\r\n\r\n// Mocking Request properties\r\nconst mockRequest = (body: any) => {\r\n  return {\r\n    body,\r\n  } as Request;\r\n};\r\n\r\ndescribe(\"InquiryController\", () => {\r\n  describe(\"createInquiry\", () => {\r\n    it(\"should return 400 if required fields are missing\", async () => {\r\n      const req = mockRequest({ name: \"Akash\" }); // Missing email, destination\r\n      const res = mockResponse();\r\n\r\n      await createInquiry(req, res, jest.fn());\r\n\r\n      expect(res.status).toHaveBeenCalledWith(400);\r\n      expect(res.json).toHaveBeenCalledWith(\r\n        expect.objectContaining({\r\n          success: false,\r\n          message: \"Name, Email and Destination are required\",\r\n        }),\r\n      );\r\n    });\r\n\r\n    it(\"should create inquiry and return 201 on success\", async () => {\r\n      const data = {\r\n        name: \"Akash\",\r\n        email: \"akash@example.com\",\r\n        phoneNumber: \"9876543210\",\r\n        destination: \"Himalayas\",\r\n        dates: \"Next Month\",\r\n        budget: \"50000\",\r\n        details: \"Looking for fun\",\r\n      };\r\n\r\n      const req = mockRequest(data);\r\n      const res = mockResponse();\r\n\r\n      const createdInquiry = { id: \"1\", ...data, status: \"NEW\", createdAt: new Date() };\r\n      \r\n      // Fix: Typescript might complain if prismaMock isn't typed correctly in setup, \r\n      // but assuming prisma.mock.ts is correct:\r\n      // We need to ensure logic in controller matches.\r\n      // Controller uses: prisma.tripInquiry.create({ data: ... })\r\n      \r\n      // We need to cast prismaMock to any or ensure it covers TripInquiry which might be new.\r\n      // If generated client is old in node_modules, tests might fail TS check.\r\n      // But we just moved to `feature/phase-9-testing` and assume generate ran.\r\n      \r\n      (prismaMock.tripInquiry.create as jest.Mock).mockResolvedValue(createdInquiry);\r\n\r\n      await createInquiry(req, res, jest.fn());\r\n\r\n      expect(prismaMock.tripInquiry.create).toHaveBeenCalledWith({\r\n        data: {\r\n          name: data.name,\r\n          email: data.email,\r\n          phoneNumber: data.phoneNumber,\r\n          destination: data.destination,\r\n          dates: data.dates,\r\n          budget: data.budget,\r\n          details: data.details,\r\n        },\r\n      });\r\n\r\n      expect(res.status).toHaveBeenCalledWith(201);\r\n      expect(res.json).toHaveBeenCalledWith(\r\n        expect.objectContaining({\r\n          success: true,\r\n          data: createdInquiry,\r\n        }),\r\n      );\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\unit\\prisma.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\akash\\Documents\\Param_Adventures_Phase1\\apps\\api\\tests\\unit\\razorpay.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]